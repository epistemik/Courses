{* CSI 1101-X,  Winter, 1999 *}{* Assignment 6, Question #2 *}{* Identification: Mark Sattolo, student# 428500 *}{* tutorial group DGD-4, t.a. = Jensen Boire *}program a6q2 (input,output) ;type	bits = 0..1 ;	nodeptr = ^node ;	node = record			   bit: bits ;			   next: nodeptr			end ;	number = nodeptr ;{ Note: a "number" points to the least significant digit, which then points   to the second least significant digit, etc.  This arrangement is unintuitive,  but since most of the operations process the digits in this order, it makes  their code very simple and efficient.  The two routines for which this is  NOT convenient are read and write, which must convert between this internal  order and the normal left-to-right ordering of the bits.  }var	memory_count: integer;	YESorNO: char;{ *************** MEMORY MANAGEMENT ************************* }{ get_node - Returns a pointer to a new node. }procedure get_node( var P: nodeptr );BEGIN	memory_count := memory_count + 1 ;	new( P )END ;{ return_node - Make the node pointed at by P "free" (available to get_node).}procedure return_node(var P: nodeptr) ;BEGIN	memory_count := memory_count - 1 ;{****   note: there is no bogus bit value so to try to make bugs         visible I flip the bit when the node is freed.****}	P^.bit := 1 - P^.bit ;	P^.next := nil ;	dispose( P ) ;	P := nilEND ;{ ******************************************************* }{ destroy - returns all dynamic memory associated with N }procedure destroy(var N:number) ;BEGIN	if N <> nil then		BEGIN			destroy(N^.next) ;			return_node(N)		ENDEND; { proc destroy }procedure read_number( var N:number ) ;var	b: char ;{*************}		{ Insert sub-procedure insert_at_front instead of repeating the code 4x in  	  the main procedure. }	procedure insert_at_front(var L:number; V: bits) ;		var			p: nodeptr ;				BEGIN			get_node(p) ;			p^.bit := V ;					p^.next := L ;						L := p ;						END; { proc insert_at_front }{*************}BEGIN	N := Nil ; 	{ bus error if N not initialized }		{ continue loop until end-of-line }	while (not eoln) do 		BEGIN		{ read char by char }		read(b) ;				{ set node bit to 1 or 0 }		if (b = '1') then			insert_at_front(N, 1) 		else			if (b = '0') then				insert_at_front(N, 0) 			else				BEGIN				writeln('Error: improper input value: converting to 0.') ;				{ Any non-bit values are converted to a 0 bit. }				insert_at_front(N, 0) ;	 				END; { else }		END; { while }		{ clear the end-of-line char }	readln ;		{ No value entered is equivalent to a single 0 bit. }	if N = Nil then		insert_at_front(N, 0) ;	END; { proc read_number }procedure write_number( N: number ) ;{*************}		{ Much simpler to do this write recursively, and need to have the recursive call	  in a sub-procedure so can have a 'writeln' statement in the main procedure. 	  This way, the output is formatted properly in procedure assignment6q2. }	procedure recursive_write(Nx: number) ;		BEGIN		if Nx <> Nil then			BEGIN			recursive_write(Nx^.next) ;		{ Recursive calls will continue until the end }			write(Nx^.bit)					{ of the list (Nil) is reached.  Then all the bits }			END							{ will print out in reverse order. }		END; { proc recursive_write }{*************}	BEGIN	recursive_write(N) ;	{ Need a writeln at the end of the entire number for proper output. }	writeln ; 					END; { proc write_number }		procedure add ( N1,N2: number; var SUM: number) ;var	{ use an integer 'tempsum' to do the initial bit addition }	tempsum: integer ;	{ have bits 'inbit' & 'carry' for the bit sum & carry respectively }	inbit, carry: bits ;	{ need temp pointers p1 & p2 to step through N1 & N2 in the loop }	p1, p2: number ;{*************}		{ Insert the sub-procedure insert_at_end instead of repeating the code 2x in  	  the main procedure. }	procedure insert_at_end(var L:number; V: bits) ;		BEGIN			if L = nil then									BEGIN				get_node(L) ;				L^.bit := V ;				L^.next := nil ;				END  { if }			else				insert_at_end(L^.next, V) ;			END; { proc insert_at_end }{*************}	BEGIN	carry := 0 ;	{ set carry for least significant bit to 0 }		{ p1 and p2 get N1 and N2 respectively }	p1 := N1 ;	p2 := N2 ;		SUM := Nil ;		{ bus error if SUM not initialized }	{ continue through loop while either p1 (N1)  or p2 (N2) still contain bits. }	while ((p1 <> Nil) or (p2 <> Nil)) do			BEGIN		if (p1 = Nil) then			tempsum := p2^.bit + carry 		{ if no p1 only: sum = p2 + carry }		else			if (p2 = Nil) then				tempsum := p1^.bit + carry 		{ if no p2 only: sum = p1 + carry }			else				tempsum := p1^.bit + p2^.bit + carry ; 	{ if p1 & p2: sum = p1 + p2 + carry }		{ convert the tempsum to a bit and set carry }		if (tempsum < 2) then				BEGIN			inbit := tempsum ;		{ if tempsum = 0 or 1, then inbit = tempsum }			carry := 0 ;				{ & carry = 0 }			END  		else			BEGIN			inbit := (tempsum - 2) ;	{ if tempsum >= base (2), then inbit = tempsum - base }			carry := 1 ;					{ &  carry = 1 }			END ;		insert_at_end(SUM, inbit) ;		{ insert the current bit into SUM }		{ move the pointers p1 & p2 if they are not at Nil }		if p1 <> Nil then			p1 := p1^.next ;		if p2 <> Nil then			p2 := p2^.next ;		END; { while }	{ after the loop: if there is a final carry, insert it into SUM } 	if (carry = 1) then		insert_at_end(SUM, carry) ;		END; { proc add } { =========== TESTING PROCEDURES ============= }procedure assignment6q2;var	N1,N2,Sum: number ;BEGIN	writeln('please enter your first binary number');	read_number(N1);	writeln('please enter your second binary number');	read_number(N2);	write('N1 = ');	write_number(N1);	write('N2 = ');	write_number(N2);	add(N1,N2,Sum);	write('Sum = ');	write_number(Sum);	destroy(N1) ;	destroy(N2) ;	destroy(Sum)END ;{***** YOU MUST CHANGE THIS PROCEDURE TO DESCRIBE YOURSELF *****}procedure identify_myself ;  { Writes who you are to the screen }BEGIN   writeln ;   writeln('CSI 1101-X (winter,1999).  Assignment #6, Question #2.') ;   writeln('Mark Sattolo, student# 428500.') ;   writeln('tutorial section DGD-4, t.a. = Jensen Boire');   writelnEND ;BEGIN  { main program }  identify_myself ;repeat  memory_count := 0 ;  assignment6q2 ;  writeln('Amount of dynamic memory allocated but not returned (should be 0) ',           memory_count:0) ;  writeln('Do you wish to continue (y or n) ?') ;  readln(YESorNO);until (YESorNO <> 'y')END.