{*****   THIS IS NOT THE handout program for Assignment #8	   *****}{*****   this is just a portion of the handout program			   *****}{*****   that you should bring to class Monday, March 15		   *****}program simulator (input,output) ;{ the following constants give symbolic names for the opcodes }const 	lda = 91 ;	{ Load Accumulator from memory }	sta = 39 ;	{ Store Accumulator into memory }	cla = 08 ;	{ Clear (set to zero) the Accumulator }	inc = 10 ;	{ Increment (add 1 to) the Accumulator }	add = 99 ;	{ Add to Accumulator }	sub = 61 ;	{ Subtract from Accumulator }	jmp = 15 ;	{ Jump ("go to")  }	jz = 17 ;	{ Jump if the Zero status bit is TRUE }	jn = 19 ;	{ Jump if the Negative status bit is TRUE }	dsp = 01 ;	{ Display (write on the screen) }	hlt = 64 ;	{ Halt }type	 byte = -99..99 ;	 word = 0000..9999 ;	 bit  = boolean ;var 	memory: array[word] of byte ;		{ the following are the registers in the CPU }    pc:		word ;	{ program counter }    a:		byte ;	{ accumulator }    opCode:	byte ;	{ the opcode of the current instruction }    opAddr:	word ;	{ the operand of the current instruction - it is always an address }    z:		bit  ;	{ "Zero" status bit }    n:		bit  ;	{ "Negative" status bit }    h:		bit  ;	{ "Halt" status bit }    mar:		word ;	{ Memory Address register }    mdr:		byte ;	{ Memory Data register }    rw:		bit  ;	{ Read/Write bit.  Read = True; Write = False }{ Loads a machine language program into memory starting at location 0 }{ *** NOTE: assumes a line does not contain any TRAILING blanks. }procedure load ;var	address: word ;	first_character, ch: char ;	inputfile : string ;	progfile : text ;BEGIN	writeln('Enter the name of the file with the program.') ;	readln(inputfile) ;	assign(progfile, inputfile) ;	reset(progfile) ;	address := 0 ;	while not EOF(progfile) do		BEGIN		if not eoln(progfile) then			BEGIN			read(progfile, first_character);			if first_character <> ' '  then { non-blank indicates a comment }				repeat                 { skip over comment }                        	read(progfile, ch)                        until ch = first_character ;			while not eoln(progfile) do				BEGIN				read(progfile, memory[address]) ;				address := address + 1				END  { while not eoln }			END;  { if not eoln }		readln(progfile)		END;  { while not eof }	close(progfile)END;  { proc load }procedure  access_memory ;BEGIN	if rw then		mdr := memory[mar] { TRUE  = read = copy a value from memory into the CPU }	else		memory[mar] := mdr { FALSE = write = copy a value into memory from the CPU }END ;procedure run ;   { This implements the Fetch-Execute cycle }BEGIN   pc := 0 ;      { always start execution at location 0 }   h := false ;  { reset the Halt status bit }   REPEAT   	 { FETCH OPCODE }       mar := pc ;       pc := pc + 1 ;  { NOTE that pc is incremented immediately }       rw := true ;       access_memory ;       opCode := mdr ;       	{ If the opcode is odd, it needs an operand.      FETCH THE ADDRESS OF THE OPERAND }       if (opCode mod 2) = 1 then               BEGIN               mar := pc ;               pc := pc + 1 ;  { NOTE that pc is incremented immediately }               rw := true ;               access_memory ;               opAddr := mdr ;  { this is just the HIGH byte of the opAddr }               mar := pc ;               pc := pc + 1 ;  { NOTE that pc is incremented immediately }               rw := true ;               access_memory ;  { this gets the LOW byte }               opAddr := 100*opAddr + mdr  { put the two bytes together }               END;  { if }    { EXECUTE THE OPERATION }       case opCode of       lda: begin              mar := opAddr ;   { Get the Operand's value from memory }              rw := true ;              access_memory ;              a := mdr        { and store it in the Accumulator }              end;       sta: begin			mar := opAddr ;  { Get the memory address of the location to store the value }			rw := false ;			mdr := a ;		{ Store the value of the Accumulator in the MDR }			access_memory	{ Transfer the MDR value to memory }              end;       cla: begin			a := 0 ;		{ set a to zero }			z := (a = 0) ;		{ set the Status Bits appropriately }			n := (a < 0) 		 end;       inc: begin			a := a + 1 ;	{ increment a }			z := (a = 0) ;		{ set the Status Bits appropriately }			n := (a < 0) 		 end;       add: begin              mar := opAddr ;	{ Get the Operand's value from memory }              rw := true ;              access_memory ;              a := (a + mdr) mod 100 ;	{ and add it to the Accumulator }              z := (a = 0) ;	{ set the Status Bits appropriately }              n := (a < 0)               end;       sub: begin			mar := opAddr ;   { Get the Operand's value from memory }			rw := true ;			access_memory ;			a := (a - mdr) mod 100 ;	{ and subtract it from the Accumulator }			z := (a = 0) ;		{ set the Status Bits appropriately }			n := (a < 0)               end;       jmp :  pc := opAddr ;	{ jump to the instruction at opAddr }       jz :  if z then pc := opAddr ;  { if the Z status bit is true then the next instruction       								to execute is at address opAddr }       jn :  if n then pc := opAddr ;  { if the N status bit is true then the next instruction       								to execute is at address opAddr }       hlt:  h := true ;   { set the Halt status bit }       dsp: begin              mar := opAddr ;   { Get the Operand's value from memory }              rw  := true ;              access_memory ;              writeln('memory location ', mar:5, ' contains the value ', mdr:3)              end                     end  { case }   UNTIL  h  { continue the Fetch-Execute cycle until Halt bit is set }END;  { proc run }BEGIN  { main program }  load ;  run ;  writeln('PROGRAM ENDED.')END.