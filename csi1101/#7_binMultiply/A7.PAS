{ CSI 1101-X,  Winter, 1999 }{ Assignment 7 }{ Identification: Mark Sattolo, student# 428500 }{ tutorial group DGD-4, t.a. = Jensen Boire }program a7 (input,output) ;type	bits = 0..1 ;	nodeptr = ^node ;	node =	record				bit: bits ;				next: nodeptr			end ;	number = nodeptr ;	markfile = text ;var	memory_count: integer;{ *************** MEMORY MANAGEMENT ************************* }procedure get_node( var P: nodeptr );BEGIN	memory_count := memory_count + 1 ;	new( P )END ;procedure return_node(var P: nodeptr) ;BEGIN	memory_count := memory_count - 1 ;	P^.bit := 1 - P^.bit ;		{* note: there is no bogus bit value so to try to make  *}	P^.next := nil ;			{* bugs visible I flip the bit when the node is freed.   *}	dispose( P ) ;	P := nilEND ;{ ******************************************************* }procedure destroy(var N:number) ;BEGIN	if N <> nil then		BEGIN			destroy(N^.next) ;			return_node(N)		ENDEND; { proc destroy }procedure insert_at_front(var L: number; V: bits) ;var	p: nodeptr ;		BEGIN	get_node(p) ;	p^.bit := V ;			p^.next := L ;				L := p ;				END; { proc insert_at_front }procedure insert_at_end(var L:number; V: bits) ;BEGIN	if L = nil then							BEGIN		get_node(L) ;		L^.bit := V ;		L^.next := nil ;		END  { if }	else		insert_at_end(L^.next, V) ;	END; { proc insert_at_end }procedure read_number(var L, T: markfile; var N:number ) ;var	b: char ;BEGIN	N := Nil ; 	{ runtime error if N not initialized }	while not eoln(L) do 		BEGIN		read(L, b) ;		case b of 			'1' : insert_at_front(N, 1) ;			'0' : insert_at_front(N, 0) ;			else				BEGIN				writeln(T, 'Error: improper input value: converting to 0.') ;				insert_at_front(N, 0) ;	 				END  { else }			end  { case }		END; { while }	readln(L) ;	if N = Nil then		insert_at_front(N, 0) ;END; { proc read_number }procedure write_number(var T: markfile; N: number) ;BEGINif N <> Nil then	BEGIN	write_number(T, N^.next) ;		write(T, N^.bit)	ENDEND; { proc write_number }		procedure add (N1, N2: number; var Sum: number) ;var	tempsum: integer ;	inbit, carry: bits ;	p1, p2: number ;BEGIN	carry := 0 ;		p1 := N1 ;	p2 := N2 ;	Sum := Nil ;		{ runtime error if Sum not initialized }	while ((p1 <> Nil) or (p2 <> Nil)) do			BEGIN		if (p1 = Nil) then			tempsum := p2^.bit + carry		else			if (p2 = Nil) then				tempsum := p1^.bit + carry 			else				tempsum := p1^.bit + p2^.bit + carry ; 		if (tempsum < 2) then				BEGIN			inbit := tempsum ;			carry := 0 ;				END  		else			BEGIN			inbit := (tempsum - 2) ;			carry := 1 ;				END ;		insert_at_end(SUM, inbit) ;			if p1 <> Nil then			p1 := p1^.next ;		if p2 <> Nil then			p2 := p2^.next ;		END; { while }	if (carry = 1) then		insert_at_end(SUM, carry) ;END; { proc add } { ******************************************************* }procedure multiply (N1, N2: number; var shift, prod: number) ;var	count, i: integer ;	mult, tempProd: number ;BEGIN	{ initialize count - keeps track of the number of places to shift in N1 }	count := 0 ;	{ use pointers shift and mult to step through N1 and N2 respectively }	shift := N1 ;	mult := N2 ;	{ initialize prod - ?runtime error if prod not initialized? }	prod := Nil ;			{ continue loop as long as N2 is not Nil }	while mult <> Nil do			BEGIN		{ process only if the current bit of N2 is 1 }		if (mult^.bit = 1) then			BEGIN			{ shift N1 the required number of places - i.e. the number in 'count' }			for i := 1 to count do				insert_at_front(shift, 0) ;			{ add the shifted N1 to the current prod and store the total in tempProd }			add(prod, shift, tempProd) ;			{ destroy the old prod to release the nodes }			destroy(prod) ;				{ prod gets the new total }			prod := tempProd ;				{ reset count - next loop will add zero's, if needed, to the existing 'shift' }			count := 0 ;			END;  { if }		{ increment 'count' so the next loop will add one more zero to 'shift', if necessary }		inc(count) ;			{ if not at Nil, move to the next node of N2 }		if mult <> Nil then			mult := mult^.next ;			END; { while }			{ if N2 was Nil or all zero's and prod stayed at Nil, then prod gets zero }	if (prod = Nil) then			insert_at_front(prod, 0) ;END; { proc multiply } { =========== TESTING PROCEDURES ============= }procedure assignment7;var	N1, N2, shift, prod: number ;	Louise, Thomas: markfile ;BEGIN	{ open and set the output file }	assign(Thomas, 'A7.run') ; { <<<<<<<<<<<< CHANGE TO A7.OUT <<<<<<<<<< }	rewrite(Thomas) ;	{ open and set the input file }	assign(Louise, 'A7.dat') ;	reset(Louise) ;	writeln('Opened text files.') ;	writeln('==================================') ;	{ continue reading numbers from input file until end-of-file }	while not EOF(Louise) do		BEGIN		writeln('Reading numbers from file ''A7.dat''') ;		writeln(Thomas) ;		{ get first number - N1 }		read_number(Louise, Thomas, N1);		write(Thomas, 'N1 = ');		write_number(Thomas, N1);		writeln(Thomas) ;		{ get second number - N2 }		read_number(Louise, Thomas, N2);		write(Thomas, 'N2 = ');		write_number(Thomas, N2);		writeln(Thomas) ;		{ multiply the two numbers and return the product and last shifted value of N1 }		multiply(N1, N2, shift, prod);		write(Thomas, 'Product = ');		write_number(Thomas, Prod);		writeln(Thomas) ;		writeln(Thomas) ;		writeln(Thomas, '---------------------------------------------------') ;		writeln('Multiplied the given numbers and wrote product to file ''A7.run''') ;		{ return all nodes - need to destroy shift vice N1 to return the extra nodes shifted in }		destroy(shift) ;				destroy(N2) ;		destroy(Prod) ;		writeln('Returned dynamic memory.') ;		writeln ;		END ;	{ close the input and output files }	close(Louise) ;	close(Thomas) ;	writeln('====================================================') ;	writeln('Closed text files. Procedure assignment7 ended.') ;END;  { proc assignment7 }{***** YOU MUST CHANGE THIS PROCEDURE TO DESCRIBE YOURSELF *****}procedure identify_myself ; BEGIN   writeln ;   writeln('CSI 1101-X (winter,1999).  Assignment #7.') ;   writeln('Mark Sattolo,  student# 428500.') ;   writeln('tutorial section DGD-4,  t.a. = Jensen Boire');   writelnEND ;BEGIN  { main program }	identify_myself ;	memory_count := 0 ;	assignment7 ;	writeln('Amount of dynamic memory allocated but not returned (should be 0) ',			 memory_count:0) ;	writeln('PROGRAM ENDED.  See file ''A7.run'' for the output.') ;END.