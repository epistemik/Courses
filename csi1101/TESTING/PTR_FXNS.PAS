{ CSI 1101-X,   Winter 1999 }{ Mark Sattolo,  student# 428500 }{ tutorial group DGD-4,  t.a. = Jensen Boire }UNIT  Ptr_fxns ;INTERFACE type      element = real ;      pointer = ^node ;       node = record                	value: element ;			next: pointer			end ;      list = pointer ;       var	mem_count: integer ;procedure get_node( var P: pointer ) ;		{ Returns a pointer to a new node. }procedure return_node(var P: pointer) ;	{ Make the node pointed at by P "free" }procedure create_empty ( var L: list ) ;		{ Sets list L to be empty. }procedure write_list ( var L:list ) ;procedure destroy( var L:list ) ;procedure delete_first (var L:list) ;procedure pointer_to_val(var L:list; Ins: real; var P:pointer) ;procedure insert_at_front(var L:list; V: element) ;procedure insert_after_P( V: element; P: pointer) ;procedure insert_after_val(var L:list; Ins, num : real) ;procedure insert_at_end(var L:list; V: element) ;function is_increasing( L:list ): string ;procedure delete_all_vals( var L:list; V: element) ;procedure all_the_same(var L:list; var Same: boolean) ;procedure insert_before_val(var L:list; num, Ins: real) ;procedure delete_last(var L:list) ;IMPLEMENTATIONlabel 310 ;procedure get_node ;		begin  mem_count := mem_count + 1 ;  new( P )end ;procedure return_node ;		{ Make the node pointed at by P "free" }begin									   mem_count := mem_count - 1 ;   P^.value  := -7777.77 ;   		{ "scrub" memory to aid debugging }   P^.next   := P ;         			{ "scrub" memory to aid debugging }   dispose( P )end ;{**************************************************************}procedure create_empty  ;		{ Sets list L to be empty. }begin    L := nilend ;procedure write_list;var	p: pointer ;			{ temporary pointer }	size: integer ;		{ keep track of list size }begin  if L = nil then  	writeln('Empty list.')  else  	begin  	size := 0 ;        p := L ;        while p <> nil do			{ traverse list }        	begin                write( '  ', p^.value:7:2 ) ;	{ write values }                p := p^.next ;                size := size + 1 ;			{ increment size }             	end ;  { while } 	writeln; 	writeln('Size of List is:  ', size, '.') ;   	end ;  { else }end ;  { procedure }procedure destroy ;begin	if L <> Nil then		begin		destroy (L^.next) ;		return_node (L) ;		end	end;  { procedure }procedure delete_first ;var	p: pointer ;		{ temporary pointer }begin	if L = nil then		begin		writeln('Error:  List is empty.') ;		{ Error case }		{goto 310  { halt }                end  { if }	else		begin		p := L ;				{ temporary pointer gets first element }		L := p^.next ;			{ list now starts at 2nd element // OR GETS NIL IF SINGLETON L }		return_node(p) ;		{ delete what was the first element }		end  { else }end;procedure pointer_to_val ;begin	if L^.value =  ins then		p := L 	else		pointer_to_val(L^.next, Ins, p) ; end;  { procedure }procedure insert_at_front ;var	p: pointer;			{ temporary pointer }begin	get_node(p) ;	p^.value := V ;		{ new node gets V }	p^.next := L ;			{ new node continues with rest of list // INCLUDING IF L=NIL }	L := p ;				{ list now starts at new node }end;  { procedure }procedure insert_after_P ;var	q : pointer ;				{ temporary pointer }begin	get_node(q) ;		q^.value := V ;			{ new node gets V }	q^.next := p^.next ;		{ new node continues with tail of P // NEED TO CHECK FOR P=NIL }	p^.next := q ;				{ P now continues with the new node }end;  { procedure }procedure insert_after_val ;var 	p: pointer ;begin	pointer_to_val(L, Ins, p) ;	insert_after_p(num, p) ;	end;procedure insert_at_end ;begin	if L = nil then					{ Base case }		begin		get_node(L) ;		L^.value := V ;		L^.next := nil ;		end  { if }	else		insert_at_end(L^.next, V) ;	{ General case }end;  { procedure }function is_increasing ;begin	if (L = Nil) or (L^.next = Nil) then			{ Base case }		is_increasing := 'IS increasing.' 	else if (L^.value > L^.next^.value) then		{ General case, step 1 }		is_increasing := 'IS NOT increasing.' 	else		is_increasing := is_increasing (L^.next) ;	{ step 2 }end;  { function }procedure delete_all_vals ;var	p : pointer ;begin	if L <> nil then									begin		delete_all_vals(L^.next, V) ; 			if (L^.value = V) then								begin										p := L ;			L := L^.next ;			return_node(p) ;			end  { if }								end  { else }							end;  { procedure }procedure all_the_same ;begin	if (L = Nil) or (L^.next = Nil) then		Same := true	else if (L^.value <> L^.next^.value) then		Same := false		else			all_the_same(L^.next, Same) ;end;procedure insert_before_val ;var  	p: pointer;begin	if L^.value = Ins then		begin		Get_node(p) ;		p^.value := num ;		p^.next := L ;		L := p ;		end 	else		insert_before_val(L^.next, num, Ins) ;end ;procedure delete_last ;begin	if L = Nil then		begin		writeln('Sorry, the list is already empty.') ;		{goto 310  { halt }		end	else if L^.next = Nil then			begin			Return_node(L) ;			L := Nil ;			end		else			delete_last(L^.next) ;end;END.