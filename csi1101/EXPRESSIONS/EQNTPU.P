{* CSI 1101-X,  Winter 1999  *}{* Mark Sattolo,  student# 428500 *}UNIT  EqnTPU ;INTERFACE type	element = string ; 	pointer = ^node ;  	node =	record 				value: element ; 				next: pointer 			end ;	stack =	record				top: pointer ; 				size: integer ;			end ;var	continue : char ;	mem_count : integer ;procedure get_node( var P: pointer );procedure return_node(var P: pointer) ;procedure create_stack(var S:stack);procedure destroy(var S: stack);procedure write_stack(var S: stack);function top(s:stack): element ;procedure pop(var S:stack);procedure push(E: element; var S: stack) ;procedure pull(var V: element; var S: stack) ;function Priority(I: element): real ;function power(base, realexp: real): real ;function Eval(L, R: element; OP: char): element ;procedure identify_myself ; procedure get_X(var source, X: element) ;procedure error_msg ;IMPLEMENTATION{label ### ;}procedure get_node( var P: pointer );BEGIN	mem_count := mem_count + 1 ;	new( P )END ;procedure return_node(var P: pointer) ;BEGIN	mem_count := mem_count - 1 ;	P^.value := 'I am free' ;	P^.next := nil ;	dispose( P )END ;procedure create_stack(var S: stack) ;BEGIN	S.top := nil ;	S.size := 0 ;END;  { proc create_stack }procedure destroy(var S: stack) ;var	temp : stack ;BEGIN	if (S.top <> Nil) then    		BEGIN    		temp := S ;  { parameter is a stack so need a temporary stack to pass }    		temp.top := temp.top^.next ;		destroy(temp) ;		return_node(S.top) ;		S.size := (S.size -1)		END  { if }END;  { proc destroy}procedure write_stack(var S: stack);var    p: pointer ;BEGIN	if (S.size = 0) then  		writeln('Empty stack.')	else  		BEGIN  		p := S.top ;  		while p <> nil do  			BEGIN  			write( ' ', p^.value:5 ) ;  			p := p^.next  			END;  { while }		writeln		END;  { else }END;  { proc write_stack }function top(S:stack): element ;BEGIN	write('Topping: ');  write_stack(S) ;  { TESTING }	if (S.size <= 0) then		BEGIN		writeln('Top Error: Stack is already empty.');		error_msg ;		END  { if }	else		top := S.top^.value ;END;  { fxn top }procedure pop(var S: stack) ;var	p: pointer ;BEGIN	if (S.size > 0) then		BEGIN		p := S.top ;		S.top := S.top^.next ;		return_node(p) ;		S.size := (S.size - 1)		END  { if }	else		BEGIN		writeln('Pop Error: stack is already empty.') ;		error_msg ;		END;  { else }END;  { proc pop }procedure push(E: element; var S: stack) ;var	p: pointer ;BEGIN	get_node(p) ;	p^.value := E ;	p^.next := S.top ;	S.top := p ;	S.size := (S.size + 1) ;END;  { proc push }procedure pull(var V: element; var S: stack) ;BEGIN	write('Pulling: ');  write_stack(S) ;  { TESTING }	if (S.size > 0) then		BEGIN		V := S.top^.value ;		pop(S) ;		END  { if }	else		BEGIN		writeln('Pull Error: stack is already empty.') ;		error_msg ;		END  { else }END;  { proc pull }function Priority(I: element): real ;BEGIN	if I = '^' then		Priority := 3 	else if ((I = '*') or (I = '/')) then		Priority := 2 	else if ((I = '+') or (I = '-')) then		Priority := 1 	else		Priority := 0 END;  { fxn Priority }function power(base, realexp: real): real ;var	stringexp : string ;	exp : integer ;	temp : real ;BEGIN	stringexp := StringOf(realexp:3) ;	ReadString(stringexp, exp) ;  	if exp = 0 then  		power := 1  	else if (exp mod 2) = 0 then  			BEGIN  			temp := power(base, exp div 2) ;  			power := (temp * temp)  			END  { if }  		else  			BEGIN     			temp := power(base, exp div 2) ;     			power := (temp * temp * base)     			END  { else }END;   { fxn power }function Eval(L, R: element; OP: char): element ;var	left, right, tot : real ;BEGIN	ReadString(L, left) ;	ReadString(R, right) ;	case OP of	'+' : 	tot := left + right ;	'-' : 	tot := left - right ;	'^' : tot := power(left, right) ;	'*' : tot := left * right ;	'/' : tot := left / right ;	else		BEGIN		writeln('Eval Error: improper operator: ', OP) ;		error_msg ;		END  { else }	END;  { case }	Eval := StringOf(tot:7:2)END;  { fxn Eval }procedure identify_myself ; BEGIN   writeln ;   writeln('CSI 1101-X,  Winter 1999') ;   writeln('Mark Sattolo,  student# 428500.') ;   writelnEND ;procedure get_X(var source, X: element) ;var	point, numeric : boolean ;	Y: element ;BEGIN	numeric := false ;	point := false ;	X := copy(source, 1, 1) ;	delete(source, 1, 1) ;	while (X = ' ') do		BEGIN		X := copy(source, 1, 1) ;		delete(source, 1, 1)		END ;	if ((X >= '0') & (X <= '9')) then 		numeric := true ;	while numeric do		BEGIN		Y := copy(source, 1, 1) ;		if ((Y >= '0') & (Y <= '9')) then			BEGIN			X := concat(X, Y) ;			delete(source, 1, 1)			END  { if }		else if ((Y = '.') and (not point)) then				BEGIN				X := concat(X, Y) ;				point := true ;				delete(source, 1, 1) ;				END  { elsif }			else if (Y = ' ') then					delete(source, 1, 1)				else					numeric := false ;		END  { while }END;  { proc get_X }procedure error_msg ;BEGIN	writeln('Choose ''Cmd-Q'' to quit the program.');	readln; { clears the input if there is any left }	readln; { another ''enter'' will halt the program }	halt  { goto ### }END;  { proc error_msg }	END.