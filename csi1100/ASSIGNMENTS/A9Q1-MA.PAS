{ Mark Sattolo  428500     CSI-1100A  DGD-1  TA: Chris Lankester   Assignment 9, Question 1 }program  MagicSquare (input,output);const	MaxSize = 20;type	ArrayType = array[1..MaxSize, 1..MaxSize] of integer;{ *************************************************************************** }  procedure SumRow (Matrix: ArrayType; Dim, RowIndex: integer; var RowSum: integer);{ Find the sum of the elements in row RowIndex of Matrix }{ Data Dictionary        Givens:  Matrix, Dim - Matrix is a Dim x Dim matrix.        		 RowIndex - the row index for Matrix.       Results:  RowSum - the sum of the numbers in row RowIndex of Matrix. Intermediates:  ColIndex - a column index for Matrix. }  var	ColIndex : integer;  begin 	RowSum := 0; 	for ColIndex := 1 to Dim do 		RowSum := RowSum + Matrix[RowIndex, ColIndex]; end; { *************************************************************************** } procedure SumBackDiag (Matrix:ArrayType; Dim:integer; var BackDiagSum:integer); { Find the sum of the back diagonal of Matrix }{ Data Dictionary       Givens:  Matrix, Dim - Matrix is a Dim x Dim matrix.      Results:  BackDiagSum - the sum of the numbers in the back diagonal of Matrix.Intermediates:  Index - a row/column index for Matrix. } var	Index : integer;  begin 	BackDiagSum := 0; 	for Index := Dim downto 1 do 		BackDiagSum := BackDiagSum + Matrix[Index, (Dim+1-Index)]; end; 		 { *************************************************************************** } procedure InMatrix (Matrix:ArrayType; Dim, Target:integer; var Total: integer); { Find the number of times Target appears in Matrix }{ Data Dictionary       Givens:  Matrix, Dim - Matrix is a Dim x Dim matrix.       			Target - the number to search for in Matrix.      Results:  Total - the number of times that Target appears in Matrix.Intermediates:  i,j - a row & column index, respectively, for Matrix. } var	i, j : integer;  begin 	Total := 0;	for i := 1 to Dim do		for j := 1 to Dim do			if Target = Matrix[i,j] then				Total := Total + 1; end;{ *************************************************************************** } procedure TrueMagic (Matrix:ArrayType; Dim:integer; var MagicYes:boolean); { See if Matrix meets the requirements of a TRUE magic square, i.e. the numbers in the  square are 1 through Dim^2, and each number appears only once. }{ Data Dictionary       Givens:  Matrix, Dim - Matrix is a Dim x Dim matrix.      Results:  MagicYes - a boolean which is true if Matrix is a true magic square,      						and false otherwise.Intermediates:  i,j - a row & column index, respectively, for Matrix.				Total - an integer holding the answer from a call to InMatrix.				Range - a boolean which is true if an element of Matrix is in the range						of 1 to Dim^2, and false otherwise.		 Uses:	InMatrix, SQR } var	i, j, Total : integer; 		Range : boolean;  begin 	MagicYes := true; 	i := 1; 	while MagicYes and (i <= Dim) do 		begin	 	j := 1;		while MagicYes and (j <= Dim) do	 			begin	 			InMatrix(Matrix, Dim, Matrix[i,j], Total);	 			Range := (Matrix[i,j] >= 1) and (Matrix[i,j] <= SQR(Dim));	 			if (Total > 1) or (not Range) then	 				MagicYes := false;	 			inc(j);	 			end;	{ j while loop }	 	inc(i);	 	end;	{ i while loop } end;	{ procedure TrueMagic }{ *************************************************************************** } procedure SumColumn (A: arraytype; N, J: integer; var Sum: integer);{ This procedure finds the sum of the Jth column in matrix A }{ Data Dictionary        Givens:  A, N, J - A is an N x N matrix of numbers                 		   J is a column index for A       Results:  Sum - the sum of the numbers in the Jth column of A Intermediates:  I - a row index for A } var I: integer; begin 	sum:= 0; 	For I:= 1 to N do 		Sum:= Sum + A[I,J]; end;{ *************************************************************************** } procedure SumDiagonal (A: arraytype; N: integer;  var Sum: integer);{ This procedure finds the sum of the forward diagonal in matrix A }{ Data Dictionary       Givens:  A, N - A is an N x N matrix of numbers      Results:  Sum - the sum of the numbers in the forward diagonal of AIntermediates:  I - a row/column index for A } var I: integer; begin 	sum:= 0; 	For I:= 1 to N do    	Sum:= Sum + A[I,I]; end;{ *************************************************************************** }{ Program MagicSquare: See if a given matrix is a magic square, and a true magic square. }{ Data Dictionary	   Givens:	Square, N - Square is an N x N matrix.Intermediates:	i,j - a row & column index, respectively, for Square.				k - a row/column index for Square.				RowSum - the sum of the elements in a row of Square.				ColSum - the sum of the elements in a column of Square.				SumDiag1 - the sum of the elements in the forward diagonal of Square.				SumDiag2 - the sum of the elements in the back diagonal of Square.				Nsum - the common sum of the elements in a row, column, or diagonal of Square.	  Results:	Magic - a boolean which is true if Square is a (basic) magic square,	  					and false otherwise.	  			RealMagic - a boolean which is true if Square is a true magic square,	  						and false otherwise.	     Uses:	SumRow, SumBackDiag, TrueMagic, SumColumn, SumDiagonal, inc }var	Square : ArrayType;	N, i, j, k, RowSum, ColSum, Nsum, SumDiag1, SumDiag2 : integer;	Magic, RealMagic : boolean;	beginrepeat	{ start outer input loop }	{ Read in the program's givens. }	repeat	write('Please enter a value from 1 to ', MaxSize, ' [ <1 to exit ] for N: ');		readln(N);	until N <= MaxSize;	for i := 1 to N do		begin		writeln('Please enter values (with a space between) for row #', i);		for j := 1 to N do			read(Square[i,j]);		end;		{ row, sum, and diagonal calculations }	SumRow(Square, N, 1, RowSum);	SumColumn(Square, N, 1, ColSum);	Magic := (RowSum = ColSum);	if Magic then		Nsum := RowSum;		{ check that row 1 and column 1 have the same sum }	k := 2;	while Magic and (k <= N) do		begin		SumRow(Square, N, k, RowSum);		SumColumn(Square, N, k, ColSum);		Magic := (RowSum = ColSum);		if Magic then			Magic := (RowSum = Nsum);		inc(k);		end;	{ while loop Row and Sum comparisons }		if Magic then		begin		SumBackDiag(Square, N, SumDiag2);		SumDiagonal(Square, N, SumDiag1);		Magic := (SumDiag1 = SumDiag2);		if Magic then			Magic := (SumDiag1 = Nsum);		end;	{ while loop Diagonal comparisons }		{ check if a True magic square }		RealMagic := false;	if Magic then		TrueMagic(Square, N, RealMagic);		{ write out the results }	writeln;	writeln('**********************************************');	writeln('     Mark Sattolo  428500');	writeln('     CSI-1100A  DGD-1  TA: Chris Lankester');	writeln('     Assignment 9, Question 1');	writeln('**********************************************');	writeln;	for i := 1 to N do		begin		for j := 1 to N do			write(Square[i,j]:3, ' ');		writeln;		end;	{ for loop to write Square }		{ inform user of the "amount of magic" in the given matrix }		if N in [1..MaxSize] then		begin		writeln;		write('is ');		if not Magic then 			write('NOT ');		write('a ');		if RealMagic then 			write('TRUE ');		write('magic square');		if Magic then			write(' with a row/column/diagonal sum of ', Nsum);		writeln('.');		writeln('**************************************************************');		writeln;		end;	{ if N in the proper range }until	N < 1;	{ end outer input loop }end.