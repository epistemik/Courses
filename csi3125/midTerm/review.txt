========

<assign>  -->  <id>  :=  <expr>
<id>      -->  A  |  B  |  C
<expr>    -->  <id>  +  <expr>  |
               <id>  *  <expr>  |
               (  <expr>  )  |
               <id>

Show a derivation and the parse tree for each of these:

A  :=  A * (B + (C * A ))
B  :=  C * (A * C + B)
A  :=  A * (B + (C))

========

<S>  -->  a  <S>  c  <B>  |  <A>  |  b
<A>  -->  c  <A>  |  c
<B>  -->  d  |  <A>

Which of the following are in the language generated by this grammar?

abcd
acccbd
acccbcc
acd
accc

========

<S>  -->  <A>  <B>  b  b
<A>  -->  <A>  b  a  a  |  a
<B>  -->  b  b  a  <B>  |  b  b

What language does this grammar generate?

Which of these are generated by this grammar?

1. abaabbb
2. abaabaabbabb
3. abbabb
4. abaabaabbbb
5. aaabaabbbb

=========

{ n > 0 }
sum := 0;
count := n;
while count <> 0 do
begin
  count := count - 1;
  sum := sum + count;
end;
{ sum = (n-1)*n/2 }

Hint: the invariant is  n > 0  &  sum = (n-1+count)*(n-count)/2

=========

{ X = C }
if A > 0
then X := X + A
else X := X - A;
{ X = C + abs(A) }

========

NOTE

The two Scheme problems are form the textbook. Please do not blame
_me_ if they seem boring (:>).

====

(define (FOO s lis)
  ( cond ((null? lis)           () )
         ((equal? s (car lis))  lis)
         (else                  (FOO s (cdr lis)))
) )

What does this function do?

========

(define (FOOO lis)
  (cond ((null? lis) 0)
        ((not (list? (car lis)))
           (cond ((eq? (car lis) nil) (FOOO (cdr lis)))
                 (else                (+ 1 (FOOO (cdr lis)))))
           )
        (else (+ (FOOO (car lis)) (FOOO (cdr lis))))
) )

What does FOOO return?

NOTE: Scheme -- in  contrast with Lisp, and contrary to what I said
      in class -- treats nil and () as different, but nil and #f are
      the same.

=========

NOTE: this is a small bonus (:>).

====

What does "guess" return?

exception EmptyList;

fun guess([x:int])= x |
    guess(x::y) = guess([x]) |
    guess(nil) = raise EmptyList;

guess([10,20,30,40]);

========
