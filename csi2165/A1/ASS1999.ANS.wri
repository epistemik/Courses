			    CSI2165A/Assignment 1   

Issue date : Friday, September 24, 1999
Due date   : Monday, October 4, 1999, 3:45pm.

Hand In : Each student is required to do this assignment INDIVIDUALLY and to 
	  hand in the following:

(1) A 3.5" disk containing the Prolog program corresponding to questions
    1.a-d of the assignment. The file containing this program must be named 
    `assign1.ari', and must be the ONLY file on the disk. 

(2) A printout of `assign1.ari' .

(3) A maniac printout of the queries and the resulting output generated by 
    Arity Prolog for part 1.e.

(4) A handwritten, or preferably typed, answer to question 2, indicating
    all the steps and relevant information in the trace.
  
Place the above items in a suitable envelope, with the following information 
clearly marked on the outside of the envelope: complete name, student number,
assignment number and course code (CSI2165A). Deposit your envelope in 
the LOCKED BOX marked `CSI 2165A' beside the reception desk on the third 
floor of MacDonald Hall. 

IMPORTANT: Your Prolog program must conform to the programming standards 
	   described in file stndrds.txt located in 'assignments' directory of
	   CSI 2165A home page at: 
	   http://www.site.uottawa.ca/ftppub/courses/Fall/csi2165A/ .

--------------------------------------------------------------------------------------
1 - Consider the following food items taken from a restaurant menu:

    salad      : ceasar (2.50, 110), greek (3.00, 130)
    soup       : chicken (3.50, 135), mushroom (2.75, 120), 
		 onion (3.00, 140), tomato (2.50, 120)
    fish       : salmon (5.50, 540), trout (6.50, 510), tuna (5.00, 480)
    meat       : beef (4.50, 540), chicken (5.00, 430), ham (3.50, 550)
    vegetarian : fried-rice(3.50, 350), steamed-rice(3.00, 270)
    cake       : apple-pie (2.00, 300), cheese-cake (3.00, 350), 
		 danish (1.50, 250)
    ice-cream  : banana-split (3.50, 300), belle-helene (4.00, 325)
    drink      : coffee (1.25, 50), capuccino (3.00, 125), 
		 espresso (3.00, 100), tea (1.00, 40)

The numbers between parentheses represent the price and the amount of 
calories of each item. For instance, a greek salad costs $3.00 and it has 
130 calories.

a) Declare a Prolog database of all the food items above with their prices 
   and calory amounts. For example, the  ceasar salad could be declared by the 
   fact `food(salad, ceasar, 2.50, 110)'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
food(salad, ceasar, 2.50, 110).
food(salad, greek, 3.00, 130).
.....
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

b) Define the relations `appetizer(Food, Price, Cal)', `main_course(Food, Price, Cal)' and 
   `dessert(Food, Price, Cal)' that determine whether a food item Food is an appetizer, 
   a main course or a dessert, respectively. These relations should also return the 
   price and the amount of calories of Food. You must use the following classification:
   * an appetizer is composed of a salad or a soup;
   * a main course is composed of fish or meat or vegetarian;
   * a dessert is composed of cake or ice cream.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
appetizer(Food, Price, Cal) :- food(salad, Food, Price, Cal); food(soup, Food, Price, Cal).
main_course(Food, Price, Cal) :- food(fish, Food, Price, Cal); food(meat, Food, Price, Cal).
dessert(Food, Price, Cal) :- food(cake, Food, Price, Cal); food('ice-cream', Food, Price, Cal).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

c) Define the relation `meal(A, M, DS, DR)', given that a meal is composed of 
   an appetizer (represented by A), a main course (represented by M), a 
   dessert (represented by DS) and a drink (represented by DR).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
meal(A, M, DS, DR) :- appetizer(A, _, _), main_course(M, Price, Cal),
                      dessert(DS, Price, Cal), food(drink, DR, _, _).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

d) Define the relations `meal_price(A, M, DS, DR, PR)' and 
   `meal_calories(A, M, DS, DR, Cal)' that determine the price PR and the amount
   of calories Cal of each meal composed of A, M, DS and DR (as defined  in 1.c),
   respectively. 
   Note: You can use the "is" operator to evaluate a mathematical expression and match it
   to another term such as an unistantiated variable. For example if you want to set an
   uninstaniated variable X to the result of evaluating 2*12 -3, you can write:
	X is 2*12 -3
   because X is uninstantiated it will match with any valid Prolog object including
   number 21 which is the result of evaluating the expression on the right hand side of the 
   'is' operator. In effect this will set X to the value of this expression.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
meal_price(A, M, DS, DR, PR) :- appetizer(A, AP, _), main_course(M, MP, _),
                                dessert(DS, DP, _), food(drink, DR, DRP, _),
				PR is AP + MP + DP + DR.

meal_calories(A, M, DS, DR, Cal) :- appetizer(A, _, AC), main_course(M, _, MC),
                                    dessert(DS, _, DC), food(drink, DR, _, DRC),
				    Cal is AC + MC + DC + DRC.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

e) Give Prolog queries for the following questions (try to use the anonymous 
   variable, if applicable):
   i)   which meals have a greek salad, and a coffee ?
   ii)  which meals consist of a soup, a cake and an espresso ?
   iii) what are the amounts of calories of the meals that have a trout, 
	an apple-pie and a coffee ?
   iv)  what are the prices of the meals that have a mushroom soup, 
	vegetarian food and ice-cream ?
   v)   can you have a meal with more than 900 calories for less than 8 
	dollars ? Note: you can use relational operators >, < for this query.
   vi)  print all the meals except the ones which fish is their main course.
        Note: You can use \= operator to check if the left hand side operand does not
              match with the right hand side operand. For instance, try the following 
              queries and verify the results.

   ?- bob \= tom.
   yes

   ?- bob \= bob.
   no
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
i)   ?- meal(greek, M, D, cofee).
ii)  ?- meal(A, M, D, espresso), food(soup, A, _, _), food(cacke, D, _, _).
iii) ?- meal_calories(A, trout, 'apple-pie', cofee, Cal).
iv)  ?- meal_price(mushroom, M, D, DR, PR), food(vegetarian, M, _, _), food('ice-cream', D, _, _).
v)   ?- meal_calories(A, M, D, DR, Cal), Cal > 900, meal_price(A, M, D, DR, PR), PR < 8.
vi)  ?- meal(A, M, D, DR), food(Type, M, _, _), Type \= fish.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

2 -  Suppose we have the following Prolog program about companies and their employees:

1. employee(john, ibm).
2. employee(sarah, ibm).
3. employee(shawn, newbridge).
4. employee(nicolas, newbridge).
5. owns(ibm, oti).
6. owns(ibm, commquest).
7. owns(siemens, sse).
8. employee(nicole, oti).
9. employee(ben, commquest).

10. works_for(Person, Company) :- employee(Person, Company).
11. works_for(Person, Company) :- is_owned_by(A_Company, Company), 
			      employee(Person, A_Company).

12. is_owned_by(C2, C1) :- owns(C1, C2).
13. is_owned_by(C2, C1) :- owns(C1, A_Company), is_owned_by(C2, A_Company).

     Trace the following query the same way that  we did in the class and tutorials
     (i.e. current goal, unification, variable instantiation, backtracking, etc.):
	
	?- works_for(P, ibm).

     Assume that the user requests all possible solution by pressing ';'.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
(0)     works_for(P, ibm) search starts from top
		-:-
  [R10] works_for(Person, Company) :- employee(Person, Company).
	--------------------------
	P:Person Company:ibm

(1)	employee(P, ibm)  search starts from top
		-:-
  [F1]  employee(john, ibm)
	--------------------
	P:john G1 succeeds -> G0 succeeds
SYSTEM OUTPUT: P = john
USER presses ";"

RS0 -> RS1

(RS1)	employee(P, ibm)  search continues from the last match
		-:-
  [F2]  employee(sarah, ibm)
	--------------------
	P:sarah G1 succeeds -> G0 succeeds
SYSTEM OUTPUT: P = sarah
USER presses ";"

RS0 -> RS1

(RS1)	employee(P, ibm)  search continues from the last match
	G1 can not be resatisfied, there is no condition
	before employee(Person, Company) in R10, system will
	look for another fact or rule to resatisfy goal 0

(RS0)   works_for(P, ibm) search continues from the last match
		-:-
  [R11] works_for(Person, Company) :- is_owned_by(A_Company, Company), 
			              employee(Person, A_Company).
	--------------------------
	P:Person Company:ibm

(2)	is_owned_by(A_Company, ibm)  search starts from top
		-:-
  [R12] is_owned_by(C2, C1) :- owns(C1, C2).
        --------------------------
	A_Company:C2 C1:ibm

(3)	owns(ibm, A_Company)  search starts from top
		-:-
  [F5]  owns(ibm, oti)
        --------------------------
	A_Company:oti G3 succeeds -> G2 succeeds

(4)     employee(P, oti)      search starts from top
		-:-
  [F8]  employee(nicole, oti)
        --------------------------
	P:nicole G4 succeeds -> G0 succeeds
SYSTEM OUTPUT: P = nicole
USER presses ";"

RS0 -> RS4

(RS4)  employee(P, oti) search continues from the last match
       G4 can not be resatisfied, system backtracks to resatisfy
       G2 -> resatisfy G3
 
(RS3)	owns(ibm, A_Company)  search continues from the last match
		-:-
  [F6]  owns(ibm, commquest).
        --------------------------
	A_Company:commquest G3 succeeds -> G2 succeeds

(5)     employee(P, commquest) search starts from top
		-:-
  [F9]  employee(ben, commquest)
        --------------------------
	P:ben G5 succeeds -> G0 succeeds

SYSTEM OUTPUT: P = ben
USER presses ";"

RS0 -> RS5
 
(RS5)   employee(P, commquest) search continues from the last match
        G5 can not be resatisfied, system backtracks to resatisfy
        G2 -> resatisfy G3

(RS3)   owns(ibm, A_Company)  search continues from the last match
        G3 can not be resatisfied, there is no condition before 
        owns(ibm, A_Company) in R12, system will look for another fact
        or rule to resatisfy goal G2

(RS2)   is_owned_by(A_Company, ibm)  search continues from the last match
		-:-
  [R13] is_owned_by(C2, C1) :- owns(C1, A_Company), is_owned_by(C2, A_Company).
        --------------------------
        A_Company{G2}:C2 C1:ibm * Note: This is A_Company in Goal 2
                                        which is different from A_Company
					on the right hand side of R13

(6)     owns(ibm, A_Company) search starts from top
		-:-
  [F5]  owns(ibm, oti)
        --------------------------
	A_Company:oti G6 succeeds

(7)     is_owned_by(A_Company{G2}, oti) search starts from top
		-:-
  [R12] is_owned_by(C2, C1) :- owns(C1, C2).
        --------------------------
	A_Company{G2}:C2 C1:oti

(8)     owns(oti, A_Company{G2})
	G8 fails -> system will look for another definition that will
	match is_owned_by(A_Company{G2}, oti)

(RS7)   is_owned_by(A_Company{G2}, oti) search continues from the last match
		-:-
  [R13] is_owned_by(C2, C1) :- owns(C1, A_Company), is_owned_by(C2, A_Company).
	-------------------------
        A_Company{G2}:C2 C1:oti

(9)     owns(oti, A_Company)
	G9 fails -> system will look for another definition that may
        resatisfy G7 but there is no more prediactes that will match this
        goal, so G7 fails. System will backtrack

(RS6)   owns(ibm, A_Company) search continues from the last match
		-:-
  [F6]  owns(ibm, commquest).
        --------------------------
	A_Company:commquest G6 succeeds

(10)    is_owned_by(A_Company{G2}, commquest) search starts from top
		-:-
  [R12] is_owned_by(C2, C1) :- owns(C1, C2).
        --------------------------
	A_Company{G2}:C2 C1:commquest

(11)    owns(commquest, A_Company{G2})
	G11 fails, so the system will look for another predicate to
	resatisfy G10

(RS10)  is_owned_by(A_Company{G2}, commquest) search continues from the last match
		-:-
  [R13] is_owned_by(C2, C1) :- owns(C1, A_Company), is_owned_by(C2, A_Company).
	-------------------------
        A_Company{G2}:C2 C1:commquest

(12)    owns(commquest, A_Company)
	G12 fails, and there is no condition before owns(C1, A_Company) in R13.
        The system can not find another predicate that will match G10, so 
	G10 fails. The system backtracks

(RS6)   owns(ibm, A_Company) search continues from the last match
	G6 fails. There is no other condition before owns(C1, A_Company) in
        R13, so the system will look for another predicate that will match G2

(RS2)   is_owned_by(A_Company, ibm)  search continues from the last match
        There is no other match for this goal, so G2 fails

(RS0)   works_for(P, ibm) search continues from the last match
        There is no other match for this goal, so G0 fails
SYSTEM OUTPUT: no
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




 








