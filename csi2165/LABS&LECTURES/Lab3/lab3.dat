% lab 3 (28 Sept) exercise/* f1 */  c(2)./* f2 */  c(3)./* r3 */  a(X):- b(Y), d(X,Y)./* r4 */  b(X):- c(Z), d(Y,Z), e(Y,X)./* r5 */  b(Y):- c(X), e(X,Y)./* f6 */  d(1,6)./* f7 */  d(4,2)./* f8 */  d(5,2)./* f9 */  e(5,6).%is_list([]).is_list(List) :- nonvar(List) , ( List = [] ; ( List = [Head|Tail] , is_list(Tail) ) ).join([], X, X).join([H|T], X, [H|NT]) :- join(T, X, NT).%supermax([], X) :- integer(small(X)).supermax([X], X) :- number(X).supermax([X], XL) :- is_list(X), supermax(X, XL).supermax([Head|Tail], X) :- not(is_list(Head)), supermax(Tail, TL), ( Head > TL -> X = Head ; X = TL).supermax([Head|Tail], X) :- is_list(Head), supermax(Head, HL), supermax(Tail, TL), ( HL > TL -> X = HL ; X = TL).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% simple casehas_addition(_+_).% When the addition is in the left OR the right operandhas_addition(X-Y) :- has_addition(X); has_addition(Y).has_addition(X*Y) :- has_addition(X); has_addition(Y).has_addition(X/Y) :- has_addition(X); has_addition(Y).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%/* Note: This solution assumes that all the elements are numbers or other (nested) lists of numbers with at least one element. */% A helper predicate which finds the maximum of two numbersmymax(X, Y, X) :- X > Y.mymax(X, Y, Y) :- Y > X./* one element list, when the element is not a listsupermax([H], H) :- not(is_list(H)).% one element list. The element itself is a list, so find the maximum in the headsupermax([H], HM) :- is_list(H), supermax(H, HM).% general cases% The head is not a list. The maximum is the maximum of the head and % the maximum found in the tailsupermax([H|T], M) :- not(is_list(H)), supermax(T, TM), ((H > TM, M = H); M = TM).% The head itself is a list. The maximum is the greater of the max found % in the head and the max found in the tailsupermax([H|T], M) :- is_list(H), supermax(H, HM), supermax(T, TM), mymax(HM, TM, M).*/%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%member(X, [X|_]).member(X, [_|T]) :- member(X,T).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%intersection( [] , L , [] ).intersection( L , [] , [] ).intersection( [Head|Tail] , List , Intx ) :- not(member(Head, List)), intersection( Tail , List , Intx ).intersection( [Head|Tail] , List , Intx ) :- member(Head, List), intersection( Tail , List , Tintx ), not(member(Head, Tintx)), Intx = [Head|Tintx].intersection( [Head|Tail] , List , Intx ) :- member(Head, List), intersection( Tail , List , Tintx ), member(Head, Tintx), Intx = Tintx.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Intersection with an empty listintersection2([], L, []).% When the head of the first list shows up once in the second listintersection2([H|T], L2, [H|TI]) :-        intersection2(T, L2, TI),        member(H, L2), not(member(H, TI)).% When the head of the first list, is not in the second list% or shows up more than once in the second listintersection2([_|T], L2, TI) :-        intersection2(T, L2, TI).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%