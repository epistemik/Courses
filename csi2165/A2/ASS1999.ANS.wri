NOTE: The solution given for each question is just one of many possible solutions.      			    CSI2165A/Assignment 2   (Solution)-----------------------------------------------------------------------Unless explicitly stated otherwise, a list refers to a simple list in the questions below.1- Define predicate has_addition/1 which takes a mathematical expressionand succeeds if the expression includes at least one addition (+) operator.Examples:?- has_addition(2).no?- has_addition(2+3).yes?- has_addition(2-3*8+5).yes?- has_addition(8-5*6/7).no%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% simple casehas_addition(_+_).% When the addition is in the left OR the right operandhas_addition(X-Y) :- has_addition(X); has_addition(Y).has_addition(X*Y) :- has_addition(X); has_addition(Y).has_addition(X/Y) :- has_addition(X); has_addition(Y).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%2- Define predicate fold/2 which takes a list and creates another list by folding the first list in the middle.Examples:?- fold([a,b,c], A).A = [c,b,a] ->yes?- fold([a,b,c,d,e], A).A = [e,d,c,b,a] ->yes?- fold([], A).no?- fold([a], A).A = [a] ->yes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Special cases for one and two element listsfold([X], [X]).fold([X,Y], [Y,X]).% split the list to first element/middle elements/last element using % conc/3. Fold the midle and swap the first and last.fold(L, FoldedList) :-   conc([First|Middle], [Last], L),   fold(Middle, FoldedMiddle),   conc([Last|FoldedMiddle], [First], FoldedList).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%3- Define predicate variable_free/1 which takes an arithmetic expression and is true,   if the expression does not include any uninstantiated variables. The only valid    operator in the expression is '+'.    Note: You can check to see if an object is an uninstantiated variable using predicate   var/1. You can use predicate not/1 to check if a goal is not true.For instance:?- var(X). % X is an uninstantiated variableX = _0084yes?- var(2). % 2 is not an uninstantiated variableno?- X = 5, var(X). % X is not an uninstantiated variableno?- X = 5, not(var(X)). % it is true that X is not an uninstantiated variableX = 5yesExamples:?- variable_free(2+3+X).no?- X = 8, variable_free(2+3+X).X = 8yes?- variable_free(2+3).yes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% When you have a numbervariable_free(N) :- number(N).% When there is no variable in the left or right operand variable_free(X+Y) :- not(var(X)), not(var(Y)),                      variable_free(X), variable_free(Y).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%4- Define predicate expr_2_list/2 which takes an arithmetic expression which can include +,-,*,/    operators and possibly instantiated or uninstantiated variables, and creates a list    of terms appearing in the expression in a left to right order.Example:?- expr_2_list(2+X/4-Y*2, L).X = _0084Y = _0098L = [2,_0084,4,_0098,2] ->yes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% when you have a one element list, and that element is a numberexpr_2_list(X, [X]) :- number(X); var(X).% convert the left and right operand to their corresponding lists% and then concatenate themexpr_2_list(X+Y, L) :- expr_2_list(X, L1), expr_2_list(Y, L2), conc(L1, L2, L).expr_2_list(X-Y, L) :- expr_2_list(X, L1), expr_2_list(Y, L2), conc(L1, L2, L).expr_2_list(X*Y, L) :- expr_2_list(X, L1), expr_2_list(Y, L2), conc(L1, L2, L).expr_2_list(X/Y, L) :- expr_2_list(X, L1), expr_2_list(Y, L2), conc(L1, L2, L).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5- Define predicate shift_vars_right/2 which takes a list of objects and sets the second object to a list containing the elements of the first list, but all elements which are uninstantiated variables in the first list are shifted towards right (end). Make sure that otherwise, the order of elements stays unchanged.   Examples:?- shift_vars_right([a, b, X,c], A).X = _0084A = [a,b,c,_0084] ->yes?- shift_vars_right([X, b, X,c], A).X = _0084A = [b,c,_0084,_0084] ->yes?- shift_vars_right([X, Y, Z,c], A).X = _0084Y = _0098Z = _00ACA = [c,_0084,_0098,_00AC] ->yes?- shift_vars_right([1, a(X),c], A).X = _0084A = [1,a(_0084),c] ->yes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% use a helper predicated that splits the list to var and no-var% lists, and then concatenate these two listsshift_vars_right(L, A) :-        shift_vars_right(L, NVL, VL),        conc(NVL, VL, A).% simple scan and test procedureshift_vars_right([], [], []).shift_vars_right([H|T], [H|NVT], VL) :-        not(var(H)), % nonvar(H).        shift_vars_right(T, NVT, VL).shift_vars_right([H|T], NVL, [H|VLT]) :-        var(H),        shift_vars_right(T, NVL, VLT).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%6 - Define a predicate `intersection(L1,L2,L3)' that returns in L3 the intersection of lists     L1 and L2. L3 may not contain any duplicates.Examples: ?- intersection([a, b, c], [c,d, c, b], A).A = [b,c] ->yes?- intersection([a, b, c], [e,f, g, h], A).A = []yes  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Intersection with an empty listintersection([], L, []).% When the head of the first list shows up once in the second listintersection([H|T], L2, [H|TI]) :-        intersection(T, L2, TI),        member(H, L2), not(member(H, TI)).% When the head of the first list, is not in the second list% or shows up more than once in the second listintersection([_|T], L2, TI) :-        intersection(T, L2, TI).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%7 - Define the predicate `max(L,M)' that determines the maximum in the list L of numbers.Example:?- max([4,7,2,3],M).M = 7yes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% maximum of a one element listmax([X], X).% for a list that has more than one element, the max is the maximum% of the head and the maximum found in the tail max([H|T], A) :- max(T, TM), ((H > TM, A = H)); A = TM).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%8 - Define the predicate 'supermax(L,M)' that determines the maximum in the list L of numbers, where L can be a nested list. You are not allowed to use the predicate 'flatten/2' defined in class. Note that 'supermax/2' generalizes 'max/2' from question 7, since it can still handle simple lists.Example:?- supermax([[1,2,[3]],[[5],[[[[2],4]]]]],M).M = 5yes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Note: This solution assumes that all the elements are numbers or% other (nested) lists of numbers with at least one element. % A helper predicate which finds the maximum of two numbersmymax(X, Y, X) :- X > Y.mymax(X, Y, Y) :- Y > X.% one element list, when the element is not a listsupermax([H], H) :- not(is_list(H)).% one element list. The element itself is a list, so find the maximum in the headsupermax([H], HM) :- is_list(H),	             supermax(H, HM).% general cases% The head is not a list. The maximum is the maximum of the head and % the maximum found in the tailsupermax([H|T], M) :- not(is_list(H)),		      supermax(T, TM),		      ((H > TM, M = H); M = TM).% The head itself is a list. The maximum is the greater of the max found % in the head and the max found in the tailsupermax([H|T], M) :- is_list(H),	              supermax(H, HM),		      supermax(T, TM),		      mymax(HM, TM, M).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%