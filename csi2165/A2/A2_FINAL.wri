/*	Mark Sattolo  428500	CSI2165A,  J.Sayyad	Assignment #2*/%Q1has_addition( _ + _ ).has_addition(X) :- X =.. [_|[LHS,RHS]] , ( ( nonvar(LHS) , has_addition(LHS) ) ; ( nonvar(RHS) ,  has_addition(RHS) ) ).%Q2join( [] , X , X ). join( [H|T] , L1 , [H|T2] ) :- join( T, L1, T2 ).fold( [] , [] ).fold( [Single] , [Single] ).fold( [Head|Tail ] , List) :- fold(Tail, Tfold) , join( Tfold , [Head] , List ).%Q3variable_free( LHS + RHS ) :- nonvar(LHS) , variable_free(LHS) , nonvar(RHS) , variable_free(RHS).variable_free(Arg) :- atomic(Arg).%Q4expr_2_list(Exp, [Exp]) :- var(Exp) ; atomic(Exp).expr_2_list(Exp, List) :- Exp =.. [ _|[ LHS , RHS ] ] ,  expr_2_list(LHS, LL) , expr_2_list(RHS, RL) , join( LL , RL , List ) ./*Q5There must be a way to do this directly, but I didn't have time to find it.  So, I have implemented 'shift_vars_right' using two recursive predicates. */find_vars([], []).find_vars([Single], List) :- var(Single) -> List = [Single] ; L = [].find_vars([Head|Tail], List) :- find_vars(Tail, Tlist), (var(Head) -> join([Head], Tlist, List) ; List = Tlist).find_non_vars([], []).find_non_vars([Single], List) :- ( nonvar(Single) -> List = [Single] ; L = [] ).find_non_vars([Head|Tail], List) :- find_non_vars(Tail, Tlist), (nonvar(Head) -> join([Head], Tlist, List) ; List = Tlist).shift_vars_right([X|T] , L ) :- find_vars([X|T] , VL), find_non_vars([X|T] , NL), join(NL, VL, L).%Q6member(X, [X|_]).member(X, [_|T]) :- member(X,T).intersection( [] , L , [] ).intersection( L , [] , [] ).intersection( [H|T] , L , F ) :- not(member(H, L)), intersection( T , L , F ).intersection( [H|T] , L , F ) :- member(H, L), intersection( T , L , TF ), not(member(H, TF)), F = [H|TF].intersection( [H|T] , L , F ) :- member(H, L), intersection( T , L , TF ), member(H, TF), F=TF.%Q7%max( [], no_max_in_empty_list ). // 'max' will crash on ';' with this line.max( [Max] , Max ) :- number(Max).max( [H|T] , L ) :- max( T , L2 ) , ( H > L2 -> L = H ; L = L2 ) ./*Q8There are a lot if 'if-then's in this predicate, but it seemed the best way to handle all the possible cases. */supermax( [] , no_max_in_empty_list ).supermax( [Single] , Single ) :- number(Single).supermax( [ H|T ] , L ) :- ( number(H) -> HF = H ; supermax( H, HF ) ) , supermax( T, TF ) , ( atom(TF) -> L = HF ; ( atom(HF) -> L = TF ; ( HF >= TF -> L = HF ; L = TF ) ) ).