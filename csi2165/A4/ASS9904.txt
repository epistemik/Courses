                            CSI2165A/Assignment 4    Issue date : Saturday, November 27, 1999Due date   : Monday, Dec. 6, 1999, 8:00pm (OFFICIAL)Extension  : Friday, Dec. 10, 1999 5:00pmHand In : Each student is required to do this assignment INDIVIDUALLY and to           hand in the following:(1) A 3.5" disk containing the Prolog program corresponding to the questions    of the assignment. The file containing this program must be named     `assign4.ari', and must be the ONLY file on the disk. (2) A printout of `assign4.ari' .(3) A printout of the queries you applied to test your solutions. Your queries    must represent 'good' test cases, i.e. they are likely to expose an error,     if any.Place the above items in a suitable envelope, with the following information clearly marked on the outside of the envelope: complete name, student number,assignment number and course number (CSI2165A). Deposit your envelope in the LOCKED BOX marked `CSI 2165A' beside the reception desk on the third floor of MacDonald Hall. IMPORTANT: your Prolog program must conform to the programming standards            described in  file stndrds.txt which is in directory assignments           of the CSI2165A course directory. MARKING SCHEME: 10% of the marks are allocated to programming standards,                while the remaining 90% will be divided among the questions                of the assignment.-----------------------------------------------------------------------1. Define the predicate is_bst(T) which is true if T is a binary search tree.   Hint: Consider the approach that we used in finding the maximum and minimum         element in a binary tree. 2. Define the predicate horizontal(BT, List) which returns in List the result   of left to right traversing of consecutive levels of a binary tree. The    root of a tree is at level 1. The immediate subtrees of the root is at level   2. Their immediate subtrees are at level3, etc.        Example:                       x             ---------------------             |                   |             a                   d         ---------       -----------------         |       |       |               |         2       8       b               z                 -----                     |                     9   The result of traversing the above tree using horizontal will generate the   following list:   [x, a, d, 2, 8, b, z, 9]   Hint: If the tree is not empty then put the root in the path list. Put the          left and right subtrees in a queue.          Process the queue until it is empty. If the head of the queue is a binary tree         then  move the root to the path list and append the left and right subtrees         of this binary tree to the queue. Continue processing the queue. You should         handle empty subtrees (nil) appropriately so that they do not show up in the         path list.   The above example in Prolog:   def_bt3(BT) :- BT = bt(bt(bt(nil, 2,nil), a, bt(nil, 8, bt(nil, 9, nil))), x, bt(bt(nil, b, nil),d,bt(nil, z, nil))).   ?- def_bt3(BT), horizontal(BT, List).      BT = bt(bt(bt(nil, 2,nil), a, bt(nil, 8, bt(nil, 9, nil))), x, bt(bt(nil, b, nil),d,bt(nil, z, nil)))      List = [x, a, d, 2, 8, b, z, 9]3.a)   Consider the following general representation of trees.    * A tree with one node D is represented as t(D)   * A tree T with root R and N children is represented as a structure with     functor t and N + 1 arguments, in which the first argument is the root      of the tree (R), and the second up to N+1'th arguments represent the      children of T, which themselves can be a tree.   For example the following tree                        a        +---------------+---------------+        |               |               |        b               c               t                +-------+-------+       +                |               |       |                e               4       g   is represented as:        t(a, t(b), t(c, t(e), t(4)), t(t, t(g)))             a)Write predicate sum_tree(Tree, STree) in which Tree is a tree representedas described above, and STree is a tree with the same structure (the same number of nodes, at exactly the same position as nodes in Tree. The dataportion of each leaf in Tree is a number. The leaves in Stree are the sameas leaves in Tree, but the data part of any other non-leaf node in STree isthe sum of the data values in the children of that node. In other words thedata part of every non-leaf node N in Tree, is replaced with a new value in the data part of the corresponding node in Stree. The new value is the sum of the data parts of the children of the node (all numbers) in STree.    Example:?- sum_tree(t(_, t(_, t(2), t(3)), t(8), t(3, t(6), t(1))), NT).NT = t(20,t(5,t(2),t(3)),t(8),t(7,t(6),t(1)))yes?- sum_tree(t(10,t(1), t(2)), NT).NT = t(3,t(1),t(2))yes?- sum_tree(t(_,t(8), t(6)), NT).NT = t(14,t(8),t(6))yesb)  Write predicate add(T1, T2, T3) in which T1, T2, and T3 are trees represented   as described above. The nodes in T3 are generated by adding the corresponding  elements in T1 and T2. If a node in T1 or T2 does not exist you should assume  that the value of the node is 0, (a leaf node with value 0).Examples:Note that the extra space among elements of the structures used in the exampleis just for the sake of clarity, and helping you to understand the examples.?- T1 = t(1,  t(2),  t(3, t(4, t(5)), t(6, t(7))      )),   T2 = t(1,  t(-2), t(3, t(6, t(6)), t(7, t(0)), t(9))),   add(T1, T2, Sum).Sum = t(2,t(0),t(6,t(10,t(11)),t(13,t(7)),t(9))) ?- T1 = t(1,  t(2),  t(3, t(4, t(5)            ), t(6, t(7), t(10))      )),   T2 = t(1,  t(-2), t(3, t(6, t(6), t(3, t(4))), t(7, t(0)       ), t(9))),   add(T1, T2, Sum).Sum = t(2,t(0),t(6,t(10,t(11),t(3,t(4))),t(13,t(7),t(10)),t(9)))4. Write predicate min_in_column(N, Functor/Arity, Min) in which Min is instantiated   to the greatest value among the values of argument N of facts in the database   with name Functor and arity equal to Arity. You can not use predicate findall/3,    , bagof/3, or setof/3. Examples: a(1, 2, 13).a(6, 3, 4).a(4, -2, 8).a(5, 10, 8).a(3, 5, 6, 8).a(67, 7).a(4, 103).?- min_in_column(1, a/3, Max). % minimum value of the first argument of a/3 factsMax = 1yes?- min_in_column(2, a/3, Max). % minimum value of the second argument of a/3 factsMax = -2yes?- min_in_column(3, a/3, Max). % minimum value of the third argument of a/3 factsMax = 4yes?- min_in_column(1, a/4, Max). % minimum value of the first argument of a/4 factsMax = 3yes5_ Define predicate split/2 which takes an atom which is representing a variable name   in language L, and breaks it to the words which it is built from. In Language L,   a variable name is a combination of lower and upper case letters, numbers, and '_',   starting with a lower case letter or '_'. The words in a variable are separated   from each other either by using '_' characters, or a mix case usage, in which each   word starts with an upper case letter, except perhaps for the first word. Your    predicate should FAIL with a massage similar to the one given in the examples, if the   variable name is not valid.Examples: ?- break(pointerToElement2, L).L = [pointer,'To','Element2']yes?- break('array_index', L).L = [array,index]yes?- break('2nd_pointerToElement2', L).2nd_pointerToElement2 is not a valid variable nameno?- break('_pointerToElement2', L).L = [pointer,'To','Element2']yes?- break('Here_is_A_mixExample', L).L = ['Here',is,'A',mix,'Example']yes6- Write predicate indexed_add(S1, S2, Index1, Index2, Answer) in which S1 andS2 are two structures, and Index1 and Index2 are simple lists of number. Index1and Index2 are used as list of indices of elements of S1 and S2 respectively.This means that a number such as 3 in Index1 is referring to the third elementof S1, and 5 in Index2 is referring to the fifth element of S2. S1 and S2 mayhave different number of arguments, but their arguments, if any,are numbers. The same holds for Index1 and Index2. They may be lists withdifferent lengths. Furthermore, the indices in Index1 and Index2 may referto an element in S1 or S2 which does not exist. In this case the assumptionis that the value of that element is zero. Answer is a structure with functor"result" and arity equal to the greater of the arity of S1 and S2. The nth elementsof the structure result is the sum of the elements of S1 and S2 at positionsreferred to by the nth elements of Index1 and Index2. If one of the lists is shorterthan the other, then for each element in the shorter list that does not existyou assume that the value of the argument in the corresponding structure waszero.Note: To simplify the solution, you may want to consider writing a predicatethat takes a structure and a number and a variable as its arguments. If thestructure had an argument in the position indicated by the number then the variablewill be instantiated to that argument, otherwise the variable will be instantiated to zero.Example:?- S1 = a(1, 3, 4),   S2 = b(2, 4, 6, -1),   Index1 = [3, 4, 1, 2, 6],   Index2 = [3, 3, 2],   indexed_add(S1, S2, Index1, Index2, Answer).Answer = result(10, 6, 5, 3, 0)yes?- S1 = a(1, 3, 4),   S2 = b,   Index1 = [3, 4, 1, 2, 6],   Index2 = [3, 3, 2],   indexed_add(S1, S2, Index1, Index2, Answer).Answer = result(4, 0, 1, 3, 0)yes