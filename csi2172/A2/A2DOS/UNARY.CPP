// File: unary.cpp// NAME: Mark Sattolo// STUDENT #: 428500// SECTION: CSI 2172A// MARKING SECTION: A4#include "unary.h"#include <math.h>// CONSTRUCTORunary_plus::unary_plus(expression* p):operand(p) 	{ }// COPY CONSTRUCTOR: it creates a carbon copy, using cloneunary_plus::unary_plus(const unary_plus& p): operand( p.operand->clone() ) 	{ }// DESTRUCTORunary_plus::~unary_plus() 	{ delete operand ; }// ASSIGNMENT OPERATORunary_plus& unary_plus::operator=(const unary_plus& p) 	{	delete operand ; 	// destroy	operand = p.operand->clone() ; 	// copy	return *this;	}// evaluate: return operanddouble unary_plus::evaluate(context& C) const 	{	return (operand->evaluate(C)) ; 	}// clone: create a carbon copyexpression* unary_plus::clone() const 	{ return new unary_plus(*this) ; }// print expression on osvoid unary_plus::print(ostream& os) const 	{	os << '+'; 	// the unary_plus operator will be the '+' sign	operand->print(os); // print operand	}// instantiatorexpression* instantiate_unary_plus(expression* e) 	{ return new unary_plus(e) ; }/*****************************************************************/// CONSTRUCTORunary_minus::unary_minus(expression* m):operand(m) 	{ }// COPY CONSTRUCTOR: it creates a carbon copy, using cloneunary_minus::unary_minus(const unary_minus& m): operand( m.operand->clone() ) 	{ }// DESTRUCTORunary_minus::~unary_minus() 	{ delete operand ; }// ASSIGNMENT OPERATORunary_minus& unary_minus::operator=(const unary_minus& m) 	{	delete operand ; 	// destroy	operand = m.operand->clone() ; 	// copy	return *this;	}// evaluate: return operanddouble unary_minus::evaluate(context& C) const 	{	return ( 0 - operand->evaluate(C) ) ; 	}// clone: create a carbon copyexpression* unary_minus::clone() const 	{ return new unary_minus(*this) ; }// print expression on osvoid unary_minus::print(ostream& os) const 	{	os << '-'; 	// the unary_minus operator will be the '-' sign	operand->print(os); // print operand	}// instantiatorexpression* instantiate_unary_minus(expression* e) 	{ return new unary_minus(e) ; }