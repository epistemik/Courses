// File: contextfun.cpp// NAME: Mark Sattolo// STUDENT #: 428500// SECTION: CSI 2172A// MARKING SECTION: A4#include "contextfun.h"//  DECLAREdeclare::declare():size(0)  // DEFAULT CONSTRUCTOR	{	}declare::declare(expression** e, int k) // 2nd Constructor	{	names = new expression*[k] ;	for ( int i = 0 ; i < k ; i++ )   		names[i] = e[i] ;	size = k ;	}// COPY CONSTRUCTOR: creates a carbon copy, using clonedeclare::declare(const declare& d):names(d.names), size(d.size)	{	}// DESTRUCTORdeclare::~declare()	{ delete [] names ; }// ASSIGNMENT OPERATORdeclare& declare::operator=(const declare& d)	{	 // destroy old array	 delete [] names ;	 // create new array	 names = d.names ;	 size = d.size ;	 return *this;	}// evaluate: add variables to current contextdouble declare::evaluate(context& D) const	{	 if (size != 0)	    for ( int i = 0 ; i < size ; i++ )	   	D.add_identifier( names[i]->get_name() );	 return 0;	}// clone: create a carbon copyexpression* declare::clone() const	{ return new declare(*this) ; }// print expression on osvoid declare::print(ostream& os) const	{	   os << "declare(";	   for( int i = 0 ; i < size ; i++ )	   	{		  os << ( names[i]->get_name() ) ;		 ( (i + 1) < size ) ? os << "," : os << "" ; 		 }	   os << ')' ;	}// instantiatorexpression* instantiate_declare(expression** argv, int size)	{ return new declare(argv, size) ; }//  ASSIGNMENTassignment::assignment(expression* l, expression* r):lhs(l),rhs(r) // CONSTRUCTOR	{	}// COPY CONSTRUCTOR// it creates a carbon copy, using cloneassignment::assignment(const assignment& a):lhs(a.lhs->clone()),rhs(a.rhs->clone())	{	}// DESTRUCTORassignment::~assignment()	{	   delete lhs ;	   delete rhs ;	}// ASSIGNMENT OPERATORassignment& assignment::operator=(const assignment& a)	{	   // destroy	   delete lhs ;	   delete rhs ;	   // copy	   lhs = a.lhs->clone() ;	   rhs = a.rhs->clone() ;	   return *this ;	}// evaluate: assign the value of rhs to lhsdouble assignment::evaluate(context& A) const	{	   double temp = rhs->evaluate(A) ;	   A.set_value( lhs->get_name(), temp ) ;	   return temp ;	}// clone: create a carbon copyexpression* assignment::clone() const	   { return new assignment(*this) ; }// print expression on osvoid assignment::print(ostream& os) const	{	   lhs->print(os) ; // print lhs	   os << " = " ;	   rhs->print(os) ; // print rhs	}// instantiatorexpression* instantiate_assignment(expression* lhs, expression* rhs)	{ return new assignment(lhs, rhs) ; }