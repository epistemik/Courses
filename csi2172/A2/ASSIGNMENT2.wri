ASSIGNMENT #2 Read the  about submitting course work! Also read ``'' and ``''. Due date: To be decided ..., but probably around // November 10thDo Question #1 part A before the Midterm! Question #1 [ 20 marks ] (No code!)     trace  [ .exe ]     |     +-- trace.cpp    Running the above program produces this  using Borland 5. //part A [ 10 marks ] Explain each line of the 42 lines of output in a word or so. For example:       lines 1-2:    a1 is constructed and every instance of A has an X object which is constructed by its                   	  default constructor      lines 3-4:    same as 1,2 but for a2         lines 5-8:    a3 is constructed: the default constructor  of A is called on each slot (like 1-2)      you continue ...     //part B [ 10 marks ] Explain each line of the 41 lines of output. HINTS: USE THE DEBUGGER!!! ============================================================================//Question #2 [ 80 marks ] 	This exercise is meant to demonstrate object oriented development ( with appropriate object oriented design and model). That is, you are given an existing application and you have to add features.  As we have discussed a good design can accommodate feature extensions without code rewrite!  -- instead we subclass. To make it even more realistic, you are given the already existing classes bundled into a library with the header files expression.h, parser.h, lexer.h, and an API (Application Programming Interface) , but you cannot see the source code! ( if you bought a commercial package -- say from Microsoft -- this is exactly what you would get). 	As it stands, you can put together an application in a matter of  which can evaluate constants (and parenthesized constants). In other words, not very useful. To make it useful, you are to implement some operators and functions so it can carry out calculations. As promised, you will not have to modify code at all, just create a new subclass for each operator and function and it should all work. Implement the following operators and functions:/* Name				Type			Syntax			Result					Marks	*/unary +			unary			+ e					e							6unary -			unary			- e					-e (e negated)			6addition			binary			e1+e2 				sum of e1 and e2 		6subtraction		binary			e1-e2 				e1 minus e2 				6multiplication	binary			e1*e2 				e1 times e2 				6division			binary			e1/e2 				e1 divided by e2 		6power				binary			e1^e2 				e1 raised to e2 			10sin					function		sin(e)				sin of e 					6cos					function		cos(e)				cos of e 					6tan				function		tan(e)				tangent of e 				6_e					function		_e()				exp(1) = 2.71828 			6log					function		log(a,b)			base b logarithm of a 	10For each you have to declare a class and 	implement the constructor 	implement the copy constructor 	implement the assignment operator 	implement the destructor 	overload expression* expression::() const 	overload void expression::(ostream&) const 	overload double expression::() const 	implement an instantiator 	The class prototypes of the expressions indicated as unary should be put to the file named unary.h and implemented in the file named unary.cpp. The class prototypes of the expressions indicated as binary should be put to the file named binary.h and implemented in the file named binary.cpp. The class prototypes of the expressions indicated as function should be put to the file named function.h and implemented in the file named function.cpp. main program must be in the file named main.cpp (feel free to edit , also see the hints!).  main() must call as its first line me(cout) which you implemented for the last assignment! //HINTS 	It is very rare that a developer is assigned the task to single handedly design and develop an application from scratch not even using any third party products (in this case software libraries). It is much more realistic that the task is to be part of a team and to enhance, redevelop, rewrite or extend an existing application and to use possibly many commercially available software products (like the RSA cryptography libraries, OpenGL graphics libraries, networking libraries, database connectivity and interface libraries, ... and so on!). This also implies that the developer will not have access to all the source code may not be knowledgeable or competent in all components will use functions, classes and methods from libraries which he would not be capable to implement must read documentation and selectively choose only information he needs and skip everything else In this respect this exercise is very different from typical academic assignments where everything is developed from scratch. C++ (and C) was developed to build huge software projects with multi-siteteams. This exercise hence is more geared towards software engineering and to simulate software development. These hints apply for "real" software development as well try to draw or otherwise visualize what you have to do, do not start thinking in terms of code it is ok that you do not understand how a lexer or a parser works, this assignment does not require it! (people who write database interfaces most probably have no idea how to implement efficient "hash-joins", yet they use it all the time!) 	API documentation, reference books, collections of poems, the yellow pages and the TV-guide are not meant to be read from cover to cover. These books are meant to provide information on selected topics. Browse through the API docs (do not even bother with lexer!) and select methods that you think you may need. Reference books and API docs most often come with examples and sample code. Well here we go:         sample.exe [ .exe ]          |          +- ass2.lib [ .lib ]          |          +- expression.h [ .h ]          |          +- parser.h [ .h ]          |          +- lexer.h [ .h ]          |          +- sample.h [ .h ]          |          +- sample.cpp [ .cpp ]          |          +- sm.cpp [ .cpp ] sample.h contains the declarations of two binary operators (mod and div) one unary operator (@)  which truncates floating point numbers to integers and one function hyp which can be used to  calculate the hypotenuse of a triangle.  sample.cpp implements these operators and functions.   sm.cpp is has main and all the lines that have to be added to  have the comment // NEW.   After compiling sample, you can have the following session:           C:>sample//     8 div 3;         8 div 3 == 2//     8 mod 3;         8 mod 3 == 2//     101 div 20 mod 3;         101 div 20 mod 3 == 2//     101 div (20 mod 3);         101 div (20 mod 3) == 50//     @3.4;         @3.4 == 3//     hyp(300 div 10 div 3, @hyp(7, 32 div 9));         hyp(300 div 10 div 3,@hyp(7,32 div 9)) == 100.245//     exit;              What you type is in //green. One more hint: the implementation of the unary operators, the binary operators and the functions will be so strikingly similar that they may only differ in one word or so. Well, this should give you the hint that maybe you should create your own hierarchies of unary, binary and function expressions to save typing (or cut-and-paste). //BONUS 1 [ 25 marks ] 	The parser is capable of instantiating variables but the context class is not capable to do anything with them! Read the API docs for  and create a subclass of context called varcontext and overload the methods so it will be capable of storing and looking up variables. Implement function declare ( a subclass of expression) which can take 0 or more arguments, and is used to declare variables in the context. The value returned by declare is 0.Implement the binary operator assignment ( a subclass of expression) which is is used to assign the right-hand-side to the variable on the left hand side. When registered with the parser, make sure that assignment has lower precedence than any other operator. You should be able to have the following session with your compiled program:       C:>bonus//  declare(A,B);      declare(A,B) == 0//  A = (B = 8) ^ (1/3);      A=(B=8)^(1/3) == 2//  B;      B == 8//  D = declare(D) + 10*(A + log(B,2));      D=declare(D)+10*(A+log(B,2)) == 50//  exit;      Put the prototype of the class varcontext in the file named varcontext.h and implement it in varcontext.cpp. Put the prototype of assignment and declare in the file named context.h and implement them in contextfun.cpp. Also hand in the modified main in main2.cpp. //BONUS 2 [ 5 marks ] (and no code!) 	It is common with object oriented programs that they are ``overdesigned''. The designers often put in so called ``hooks'' into the application because they anticipate that it is likely that the application will be extended along those lines. This application was also designed that way. 	Originally only constants and variables are implemented but all kinds of other expressions can be added as far as they implement the methods evaluate and print. Also, the hook for having variables is there. The parser knows how to instantiate them and a simple (in fact useless) context class is provided so subclasses implementing its methods will be able to handle variables. 	A design said to be saturated when it can no longer handle easy feature extensions just by subclassing. This model can easily be extended by adding new expressions (like unary and binary operators and functions) and by providing subclasses of context to handle variables. 	Your task for this exercise is to come up with some simple idea to extend this model which would require some rework (adding more subclasses of expression and context do not require model rework!) and suggest a solution (no code) strategy. You are limited to the maximum of half a page typed text or 12 sentences and one diagram (like the one above) which shows where your extensions lie! 	Large companies often have departments called ``Venture Capitals'' who investigate and occasionally finance new development and enhancment ideas. They evaluate hundreds or possibly more ideas every so often. The first pass is usually a one page description which is strictly enforced. The motto is "get me interested" and if it sounds good it will be further investigated. The space restrictions on this question will be enforced by the marker so be very brief and clear, your diagram should say it all and your text should only provide support for your figure. //What do I hand in???Your answer for Question 1: make sure it is neatly written if not typed. Be very brief!A diskette with only the following files: me.cpp unary.h unary.cpp binary.h binary.cpp function.h function.cpp main.cpp Printouts of only the following files: unary.h unary.cpp binary.h binary.cpp function.h function.cpp main.cpp If you did bonus 1, also have the following files on the diskette: varcontext.h varcontext.cpp contextfun.h contextfun.cpp main2.cpp A printouts of: varcontext.h varcontext.cpp contextfun.h contextfun.cpp main2.cpp If you also did bonus 2, hand in your maximum half a page idea with one neatly drawn diagram (you do not have to use the computer to draw, but please do use a ruler and pen). Absolutely nothing else! Do not have any other files on the diskette! Those generated by Borland should be removed. Do not hand in printouts of files not explicitly asked for! Good Luck!!! 