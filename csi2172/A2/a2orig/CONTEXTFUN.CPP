// File: contextfun.cpp// NAME: Mark Sattolo// STUDENT #: 428500// SECTION: CSI 2172A// MARKING SECTION: A4#include "contextfun.h"//  DECLAREdeclare::declare():size(0)  // DEFAULT CONSTRUCTOR	{	}declare::declare(expression** e, int k) // 2nd Constructor	{	names = new expression*[k] ;   for ( int i = 0 ; i < k ; i++ )   	names[i] = e[i] ;   size = k ;	}// COPY CONSTRUCTOR: creates a carbon copy, using clonedeclare::declare(const declare& d):names(d.names), size(d.size)	{	}// DESTRUCTORdeclare::~declare()	{ delete names ; }// ASSIGNMENT OPERATORdeclare& declare::operator=(const declare& d)	{   // destroy old array   delete [] names ;   // create new array   names = d.names ;   size = d.size ;   return *this;}// evaluate: add variables to current contextdouble declare::evaluate(context& D) const	{   if (size != 0)      for ( int i = 0 ; i < size ; i++ )      	D.add_identifier(dynamic_cast<variable*>(names[i])->get_name());   return 0;}// clone: create a carbon copyexpression* declare::clone() const	{ return new declare(*this) ; }// print expression on osvoid declare::print(ostream& os) const	{   os << "declare(";   for( int i = 0 ; i < size ; i++ )   	{      os << dynamic_cast<variable*>(names[i])->get_name() ;      ( (i + 1) < size ) ? os << "," : os << "" ;   	}   os << ')' ;}// instantiatorexpression* instantiate_declare(expression** argv, int size)	{ return new declare(argv, size) ; }//  ASSIGNMENTassignment::assignment(expression* l, expression* r):lhs(l),rhs(r)  // CONSTRUCTOR	{	}// COPY CONSTRUCTOR// it creates a carbon copy, using cloneassignment::assignment(const assignment& a):lhs(a.lhs->clone()),rhs(a.rhs->clone())	{	}// DESTRUCTORassignment::~assignment()	{   delete lhs ;   delete rhs ;	}// ASSIGNMENT OPERATORassignment& assignment::operator=(const assignment& a)	{   // destroy   delete lhs ;   delete rhs ;   // copy   lhs = a.lhs->clone() ;   rhs = a.rhs->clone() ;   return *this ;	}// evaluate: assign the value of rhs to lhsdouble assignment::evaluate(context& A) const	{   double temp = rhs->evaluate(A) ;   A.set_value((dynamic_cast<variable*>(lhs))->get_name(), temp) ;   return temp ;	}// clone: create a carbon copyexpression* assignment::clone() const   { return new assignment(*this) ; }// print expression on osvoid assignment::print(ostream& os) const	{   lhs->print(os) ; // print lhs   os << " = " ;   rhs->print(os) ; // print rhs	}// instantiatorexpression* instantiate_assignment(expression* lhs, expression* rhs)	{ return new assignment(lhs, rhs) ; }