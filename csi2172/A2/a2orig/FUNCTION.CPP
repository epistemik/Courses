// File: function.cpp// NAME: Mark Sattolo// STUDENT #: 428500// SECTION: CSI 2172A// MARKING SECTION: A4#include "function.h"#include <math.h>/*********************************************************	SINE*********************************************************/// CONSTRUCTORsine::sine(expression* s): arg(s)	{ }// COPY CONSTRUCTOR: it creates a carbon copy, using clonesine::sine(const sine& s): arg( s.arg->clone() )	{ }// DESTRUCTORsine::~sine()	{  delete arg ;	 }// ASSIGNMENT OPERATORsine& sine::operator=(const sine& s)	{	delete arg ;	// destroy	arg = s.arg->clone() ;	// copy	return *this ;	}// evaluate: return the sine, in radians, of the argumentdouble sine::evaluate(context& S) const	{  return sin( arg->evaluate(S) ) ;	 }// clone: create a carbon copyexpression* sine::clone() const	{ return new sine(*this) ; }// print expression on osvoid sine::print(ostream& os) const	{	os << "sin(" ;	arg->print(os) ; // print arg	os << ')' ;	}// instantiatorexpression* instantiate_sine(expression** argv, int)	{ return new sine(argv[0]) ; }/*********************************************************	COSINE*********************************************************/// CONSTRUCTORcosine::cosine(expression* c):arg(c)	{ }// COPY CONSTRUCTOR: it creates a carbon copy, using clonecosine::cosine(const cosine& c): arg( c.arg->clone() )	{ }// DESTRUCTORcosine::~cosine()	{ delete arg ; }// ASSIGNMENT OPERATORcosine& cosine::operator=(const cosine& c)	{	delete arg ; 	// destroy	arg = c.arg->clone() ; 	// copy	return *this ;	}// evaluate: cast operand into an intdouble cosine::evaluate(context& C) const	{  return cos( arg->evaluate(C) ) ;	 }// clone: create a carbon copyexpression* cosine::clone() const	{ return new cosine(*this) ; }// print expression on osvoid cosine::print(ostream& os) const	{	os << "cos(" ;	arg->print(os) ; // print arg	os << ')' ;	}// instantiatorexpression* instantiate_cosine(expression** argv, int)	{ return new cosine(argv[0]) ; }/*********************************************************	TANGENT*********************************************************/// CONSTRUCTORtangent::tangent(expression* t): arg(t)	{ }// COPY CONSTRUCTOR: it creates a carbon copy, using clonetangent::tangent(const tangent& t): arg( t.arg->clone() )	{ }// DESTRUCTORtangent::~tangent()	{  delete arg ;	 }// ASSIGNMENT OPERATORtangent& tangent::operator=(const tangent& t)	{	delete arg ;	// destroy	arg = t.arg->clone() ;	// copy	return *this ;	}// evaluate: return the sin, in radians, of the argumentdouble tangent::evaluate(context& T) const	{  return tan( arg->evaluate(T) ) ;	 }// clone: create a carbon copyexpression* tangent::clone() const	{ return new tangent(*this) ; }// print expression on osvoid tangent::print(ostream& os) const	{	os << "tan(" ;	arg->print(os) ; // print arg	os << ')' ;	}// instantiatorexpression* instantiate_tangent(expression** argv, int)	{ return new tangent(argv[0]) ; }/*********************************************************	NUM_E*********************************************************/// CONSTRUCTORnum_e::num_e(expression* c)	{ }// evaluate: cast operand into an intdouble num_e::evaluate(context& C) const 	{  return exp( 1 ) ;  }//clone: create a carbon copyexpression* num_e::clone() const	{ return new num_e(*this) ; }// print expression on osvoid num_e::print(ostream& os) const 	{  os << 'e' ;  }// instantiatorexpression* instantiate_num_e(expression** argv, int)	{ return new num_e(argv[0]) ; }/*********************************************************	NATLOG*********************************************************/// CONSTRUCTORnatlog::natlog(expression* m, expression* n): arg1(m), arg2(n) 	{ }// COPY CONSTRUCTOR: it creates a carbon copy, using clonenatlog::natlog(const natlog& m): arg1( m.arg1->clone() ), arg2( m.arg2->clone() ) 	{ }// DESTRUCTORnatlog::~natlog()	{	delete arg1 ; 	delete arg2 ;	}// ASSIGNMENT OPERATORnatlog& natlog::operator=(const natlog& m)	{	delete arg1;	// destroy	delete arg2;	arg1 = m.arg1->clone();	// copy	arg2 = m.arg2->clone();	return *this;	}// evaluate: log of arg1 divided by log of arg2 to get log of arg1 in base arg2double natlog::evaluate(context& L) const 	{double a = arg1->evaluate(L);double b = arg2->evaluate(L);	return log(a) / log(b) ;	}// clone: create a carbon copyexpression* natlog::clone() const	{ return new natlog(*this) ; }// print expression on osvoid natlog::print(ostream& os) const	{	os << "log(";	arg1->print(os); // print arg1	os << ',';	arg2->print(os); // print arg2	os << ')';	}// instantiatorexpression* instantiate_natlog(expression** argv, int)	{ return new natlog(argv[0], argv[1]) ; }