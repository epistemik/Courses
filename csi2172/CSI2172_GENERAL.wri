General Rules Concerning Course Work =================================	Assignments are to be done and submitted by each student individually.		Hand in only the source code on a 3.5' diskette and a printout, together with possibly other 	material (documentation, object model, diagrams ...) that the question will clearly specify. 	Printout which is not accompanied by the identical source on the diskette will not be marked!		Your code is expected to be neatly spaced and commented. Every file should have the file name, 	the author and the student number and your course and marking section in a comment line as 	the very first line(s). For example: 	       // FILE: q1.cpp       // NAME: Santa Claus       // STUDENT #: 123456       // SECTION: CSI 2172A       // MARKING SECTION: A2     		You are also expected to have inline comments explaining, in a word or two, every construct 	you use and may not be obvious at first sight. You may loose marks for submitting messy 	and/or undocumented code. Always get rid off variables, print statements and libraries which 	are not essential. Unless you are specifically asked, you should not print anything to the 	console (it is indeed a good debugging technique, but get rid off them or enclose them into 	conditional compiler directives when you submit). You will loose marks if the functions and 	methods write to the console and I did not ask for it! main of course is an exception.		Cooperation is encouraged between students and groups. However, students submitting work 	for which they are not the author will be penalized at the minimum of receiving the mark 0 	for the submission. The work submitted by the person caught cheating will be retained for 	evidence. Stealing, destroying and/or submitting another student's work (even with 	modifications) is considered cheating. You may freely discuss your assignment with anyone 	and work in groups but the actual work you submit must be your own! 		Every submission must be put into a closed envelope. No paper clips, or stapled submissions! 	Clearly write your name, student number and marking section on the front of your envelope. 	The marking section is assigned by the computer at the beginning of the semester and will be 	posted. This designation has no bearing on what tutorials you visit and it does not guarantee 	that you would be marked by any particular marker. Depending on the number of submissions 	I will arbitrarily assign markers and sections for each assignment. In essence, your marking 	section is your index into the marks database. Not reporting your marking section or giving 	the wrong one will result in loosing some marks. For example:                 Assignment #1        Santa Claus        st# 123456        CSI2172A        Marking Section: A3       No partial marks for late submissions! Late papers receive the mark 0!		You may develop your assignments and project under any platform you wish. It, however, 	must run on the lab machines and should compile with no warnings under Borland 5. 	If you use Microsoft Development Studio, or gcc 2.7.x, gcc 2.8.x you should be able to port your 	code to Borland 5 with little difficulty. You have to be careful and avoid to use native 	non-standard Microsoft libraries and to turn on warning flags, template generation hints and 	exception handling with gcc. You should not use pre-ANSI compilers, specially the ones for 	MS-DOS or MS-Windows 3.1. These compilers do not (uniformly) comply with ANSI scoping 	rules, and do not support many of the now standard mechanisms. Regardless where you do 	your homework, expect to spend some time to make it compliant with Borland 5 as it is set up 	in the lab. Unfortunately C++ source code is not 100% portable (the ANSI standard is hardly a 	year old!) I developed the examples with gcc 2.7.2 and a few with gcc 2.8 on a ULTRASPARC 	running UNIX (Solaris 2.6) and they also run with no modifications on Borland 5. Excuses 	such "It runs at home on MS Development Studio" will not be accepted. It is your responsibility 	to check if your code works on Borland 5 in the University Lab! Due to the small amount and 	relatively little complexity of the code that your are expected to submit, porting should pose no 	challenge regardless what C++ development platform you use.---------------------------------------------------------------------How can I make my marker's life easier? 	Making your marker's life easier also makes your life easier. You only have to follow some very 	simple rules: - code neatly, use appropriate indentation and comments - if your code does not compile, identify the smallest block where it fails and enclose 		it in comments so your code does compile (see "What if my code does not compile?") - if a paper documentation or a diagram is required, use a word processor if you can or 	draw neatly with a pen or pencil and use a ruler - you may use highlighters to emphasize function names or important comments - always have the file name, your name, student number, and marking sections in a 	comment line in every file you submit!!! (unless the file was given) - always have the assignment number, your name, your student number and your	marking section clearly written on the envelope!!! - the marker will put his or her comments on the printouts of your code, so make sure 	it is nicely spaced and not cluttered - if your code on the diskette does not match the printout, you receive a 0 for that	question, so do not even try... - go through the marking scheme posted for each assignment and make sure you 	satisfy the check list provided with each assignment posting - do make very sure that your code developed elsewhere works on our lab equipment 	and Borland 5. No excuses! If it does not compile you only get at most 25% of the questions worth! --------------------------------------------------------------------What if my code does not compile? 		Writing syntactically correct code is not difficult. Modern compilers give good hints what 	the errors are (most even put a cursor at the exact location). In this course, code which does not 	compile may receive the maximum of 25% of the question's worth even if the syntax error is 	one missing semicolon!  Here are some suggestions how to deal with the situation:	- Compile often!  Modern computers are fast enough to compile even after every few lines! - Do not write code on paper and then type it in! If you want to work where you have no computer, 	write pseudo-code and use diagrams to get the structure or the logic right. Do not type in dozens 	of lines of code and then try to fix it. This will most certainly lead to cascading errors. This would 	be a waste of your effort.		If you are really stuck and submission deadline is close, identify the smallest section of code 	which causes the compiler to stop and comment it out. Use a highlighter on this section and let 	the marker now that even though it is incorrect you may get some partial marks for the logic. 	If you do not do this, the most you can get is 25%. -------------------------------------------------------------------Header and Implementation Files 		Textbook examples of C++ code often include the class, method and function definitions, 	declarations, initialization and the implementation in the same file. This is, however, not 	advised and in fact should always be avoided. For this course you will always have to separate 	the implementation from its interface in different files. Moreover, the file containing main 	must also be separate. Separate compilation of modules is a powerful idea and is strictly 	observed in commercial development. Header File ----------------Header files contain: - macros (pages 219-223) - external references to constants and global variables - function and class prototypes - type definitions 		In C++, no identifier, function or class can be declared more than once. Therefore it is 	important to protect multiple inclusions of the same header file. The technique widely used is 	to enclose the entire body of the file into a pair of conditional directives. A macro is defined 	as soon as the file is included so next time around (when the macro is already defined) the body 	is skipped. This macro to be defined is often derived from the file name. Suppose the header 	file is foo.h then good picks for the macro could be              _FOO_H_       FOO_H_INCLUDED       FOO_H_DEFINED   It does not matter at all what you actually call the macro, but consistency is advisable.    // Test if _FOO_H_ is defined   // if yes, skip to the #endif   #if !defined(_FOO_H_)     // _FOO_H_ is not defined, so define it   #define _FOO_H_     // external references to global variables   // and constants, class and function prototypes ...    ...   // skip right here if _FOO_H_ were defined   // when the file was included   #endif    Implementation Files -------------------------------		Implementation files should contain the definitions of the constants, variables, methods 	and functions declared in the header file. They may also contain declarations of variables, 	classes, types ... but these should be treated local to this file. Sometimes it is a good idea to 	exclude some of these declarations from the interface (header file) because they are only used 	to implement particular details and these should be hidden from the user. If that is the case, 	make sure to make them static. static variables and functions are local to the file and linker 	will not see them. This guarantees that there will be no name clashes! -----------------------------------------------------------------------Throwing Exceptions 		Exception handling (notes pages 115-120, 125-128) is an elegant and effective way to deal with 	exceptional conditions. When you implement a function or a method, you often encounter 	conditions which you can detect but cannot handle. For example what should one do if max 	is called on an empty list. The alternatives are:- Make an assumption and clearly document it: the list is not empty - Set a boolean variable that something is wrong - Return a specific value which represents an error code - Write a message on the console -- BAD! - Call exit or abort -- VERY BAD! - Throw an exception -- YES! 		Making an assumption is not necessarily bad. If it is documented and the user is aware of it, 	checking of the precondition can be done before the call. However users may not read the 	documentation and this can cause a run-time error forcing an abort without clean up. 	Setting a boolean (or integer) variable is very much used in practice because the C language 	has no exceptions. There is even a library errno.h which provides a mechanism to clear, 	set and read error indicators. This however assumes that the user of the function will clear 	and read the error flags. Returning a specific value often works. For example printf and scanf 	return the number successfully written and read variables. 		However it is often cumbersome and even dangerous to reserve a specific value. For 	example in the case of max what if the error value can naturally occur in the list? I deliberately 	emphasize writing to the console and/or aborting the program. They are indeed inappropriate. 	First, it is a silly assumption that there is actually an active console when the application is 	running and they provide no means to react to the exception condition! The cleanest, most 	elegant, most effective and easiest way to handle such occurrences is to simply throw an exception. 	When the exception is thrown stack clean up is automatic, exceptions being objects can propagate 	the actual context which may not only enable detection and reaction but also recovery!		Exceptions are discussed in detail but I want you to start using them even if you do not react 	on them. So this is all what you have to do!- declare a class which represents the exception - throw an instance of the exception when you encounter an erroneous situation    // a class representing under-indexing an array   class array_underflow {   };   ...   int max(int* a, int l) {      if (l == 0) throw array_underflow();      ...   }   		This one throw line is the easiest and the best possible thing you can do: it will invoke 	automatic local resource deallocation and it gives you a chance to react (ie catch) along 	anywhere in the chain of invocations which eventually lead to max being called with an 	empty array!