ASSIGNMENT #3Read the general rules about submitting course work! Also read ``how can Imake my marker's life easier'' and ``what if my code does not compile?''.Due date:     December 7th, by 18:00 in the hand in boxes located on the 3rd floor of     McDonald building.     Suggested dead-line: November 26th, that is you should be able to have     it done by then if you start on it now. Work on it in the labs and ask     questions from the TA's and from me in my office hours, in case you get     stuck. If you submit it in the box by November 26th 20:00, you get 5     extra marks!----------------------------------------------------------------------------Priority Queues [ 100 marks ]For this assignment you will implement a priority queue using a heap.Priority queues are one of the most used data structures in computerscience. They are used in scheduling, distributed computing andtelecommunications.                                  [Image]Usually priority queues are used to protect a resource or a server to beflooded by an abundance of requests. Those who cannot be servicedimmediately must wait in the queue. Unlike a standard queue where thepriority is the time of arrival, the objects in the priority queue areassigned priorities which determine the order of service.It is very often a requirement that the queuing itself should take verylittle time. Just think about a fast processor with hundreds of threads andprocesses waiting for time slots. Those CPU cycles are better burnt on thejob than looking for the process with the highest priority.A heap is usually used to implement priority queues, because it isguaranteed that insertions and removal of elements in priority order arenever worse than O(log2 n). A heap is a full tree (structural property)which means that every node has exactly two children, except for the leafnodes who have 0, and the last parent node which may have only 1. The objectstored in a node has higher priority than the objects stored in the childnodes (ordering property) and this is recursively true for all nodes. A newnode is always inserted to be the next node. However it may be out of order,so the sift_up algorithm is used to fix ordering.     function sift_up(node n) {        while(n != root) {           if (higher_priority(n,parent(n))) {              swap(n,parent(n));              n = parent(n);           } else {              break;           }        }     }                                  [Image]When the highest priority element is removed from the top, the last insertednode gets physically deleted and its value is placed in the root node. Thisguarantees that the tree is structurally intact but the ordering propertymay no longer hold. The sift_down algorithm can be used to fix the orderagain.     function sift_down(node n) {        while(true) {           node child = highest_priority_child(n);           if (child == nil) break;           if (higher_priority(child,n)) {              swap(n,child));              n = child;           } else {              break;           }        }     }                                  [Image]While heaps are trees, they are rarely implemented as trees! They areusually implement using arrays. If the nodes of a heap are written out to anarray starting at the root level-wise from left to right then if i is theindex of a node n   * 2*i is the index of he left child of n   * 2*i+1 is the index of he right child of n   * i/2 is the index of the parent of n(assuming that the index of the first element is 1 and not 0!)                                  [Image]sheap.cpp implements a heap using an array.Heaps - in practice - often have to be able to accommodate for prioritychanges. For example, it is possible that an intricate priority policy of amulti-processor computer decides to automatically add a small value to thepriority if the process has not been served for 1000 CPU cycles. Such apolicy may help to avoid starvation. (Well probably it won't, but this isnot a course on Queuing Theory or Simulation!). Anyhow, the policy isindependent from the implementation, hence we do not have to be concernedwith that, just provide some means that the priority of a node may changeasynchronously. Therefore we change the prototype of the push method to     handle& heap::push(Object o)In other words, push returns a reference to some object which has someinformation about where object o is stored. Keeping in mind that theposition of o will change in the heap, we return a reference rather than acopy. We should also provide a method which can use this handle object tofix o's position.     void priority_change(handle& h)That is, we call this method, if o's priority has changed (assuming that hwas returned by push(o)). The method can be implemented quite simply.Suppose handle implements the index method, which tells where exactly o isstored.     void heap::priority_change(handle& h) {        sift_down(h.index());        sift_up(h.index());     }depending whether o's priority was bumped or lowered, one of sift_down orsift_up will do the work.Often it is also a requirement that if two values have the same priorityvalue, than the one which arrived first also gets served first. This isestablished by creating a unique id for the nodes.We also want to use templates to implement the data structure, because itwould be wasteful to recode it each time a different type of value is storedin the heap. Because there is no generic way to compare objects to establishtheir priority, a comparison function must be provided, which returns trueif object1 is strictly smaller than object2. Depending whether smaller ishigher priority or larger is higher priority, the user should be specify ifordering is smaller-first or larger-first.----------------------------------------------------------------------------For this assignment, your are given the definition of a heap (heap.h) andthe implementation of most of the interface (pop, push, ...) in terms ofprimitive abstract methods (sift_up, sift_down, ...) (heap.cpp) You are alsogiven the full implementation of a heap - called linked_heap - which uses abinary tree to implement the heap (lheap.h, lheap.cpp). You are to createanother subclass called array_heap and implement it using an array.                                  [Image]HINTSYou have to implement a constructor, copy constructor, assignment operatorand destructor. Other than these, you only have to overload the abstractmethods of heap, but you may need a few private ones to do that. Forexample, it is a good idea to implement a parent, left_child and right_childmethod. You would also have to create a subclass of handle let's sayarray_node. This array_node should have an instance variable ind for indexwhich is of type integer, and stores the actual index where the value isstored in the array.You should have a protected variable representing the array:     ...     array_node** array;     ...That is the array being an array of array_node's.Start early!!! The syntax may be a bit overwhelming so you may need the TA'shelp! Syntax on the other hand is never an excuse! You do not want to say toyour employer that you cannot do C++ because you do not like the syntax.It is always a good idea to prototype what you have to do with instancediagrams. These would be drawings of heaps which show the changes as theyare pushed and popped. The following two instance diagrams should convinceyou that working with arrays is easier. (linked heap, array heap)Compiler SettingsYou must place a template instantiation line in the file instances.cpp andyou have to include the header and the implementation files!Files      heap.exe        |        +-- heap.h [ .h ]        |        +-- heap.cpp [ .cpp ]        |        +-- lheap.h [ .h ]        |        +-- lheap.cpp [ .cpp ]        |        +-- aheap.h [ .h ] you implement it        |        +-- aheap.cpp [ .cpp ] you implement it        |        +-- test.h [ .h ]        |        +-- test.cpp [ .cpp ]        |        +-- instances.cpp you modify it        |        +-- main.cpp you modify itYour definition of array_heap should be in the file aheap.h and itsimplementation in aheap.cppBONUS 1. [ 25 marks ]The problem with the array implementation is that the array size is fixedand it may overflow. Implement a subclass of array_heap calleddynamic_array_heap which resizes the array if the size with the next elementadded would exceed the capacity. If you are clever, you may need to overloadone (two at most) methods and the constructors!                                  [Image]Put the definition of dynamic_array_heap in the file daheap.h and itsimplementation in the file daheap.cpp and modify your test file, dmain.cppaccordingly. Your test should prove that you implementation can handle suchoverflows!BONUS 2. [ 5 marks ]After you implemented your assignment. You may wonder why would anyoneimplement a linked_heap when it is much more complicated than using anarray. Type a half page point form report which describes in whatcircumstances array_heap, dynamic_array_heap or linked_heap would havesuperior performance over the others.What Do I hand in?   * aheap.h   * aheap.cpp   * instances.cpp   * main.cpp   * daheap.h (in case you did the bonus)   * daheap.cpp (in case you did the bonus)Good Luck!!!