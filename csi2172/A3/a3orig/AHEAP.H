// FILE: aheap.h// NAME:  Mark Sattolo// STUDENT #:  428500// SECTION:  CSI 2172A// MARKING SECTION:  A4     #if defined(__GNUG__)#pragma interface#endif#if !defined(_ARRAY_HEAP_H_) #define _ARRAY_HEAP_H_#include "heap.h"#include <iostream.h>// heap implemented as an arraytemplate<class T>class array_heap: public heap<T>{  private:       // Subclass of heap<T>::handle -- it inherits the 'elem' variable      class a_node: public handle         {         public:            // a variable to keep track of the array index of each a_node            mutable int ind ;             // constructor	a_node(const T&, heap<T>::less&, heap<T>::order&, int) ;	// op=	a_node& a_node::operator=(const a_node& a)  ;         }; // class array_heap::a_node      // print a node and all its sub-nodes      void print(ostream&, const a_node*, int = 0) const ;  protected:       // the variables of array_heap      int max_size ;      a_node** array ;      // some useful methods      void swap(handle&, handle&) ;      int left(int) const ;      int right(int) const ;      int parent(int) const ;      int last() const ;      // pure virtual methods of parent class 'heap' are declared      void sift_up(handle&) ;      void sift_down(handle&) ;      handle& create_new(const T&) ;      handle& first() ;      void move_last_to_first() ;      void delete_last() ;      handle& index(const handle&) const ;  public:      // constructor with default array size of 30      array_heap(less, order, int=30) ;	// copy constructor	array_heap(const array_heap<T>&) ;	// assignment overload	array_heap<T>& operator=(const array_heap<T>&) ;	// destructor	~array_heap() ;      //       void print(ostream&) const ;      // pure virtual method of parent class 'heap' declared      const T& top() const ;};#endif