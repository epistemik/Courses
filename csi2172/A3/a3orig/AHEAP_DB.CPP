// aheap.cpp#if defined(__GNUG__)#pragma implementation#endif#include "aheap.h"// A_NODE METHODStemplate<class T>array_heap<T>::a_node::a_node(const T& e, heap<T>::less& f, heap<T>::order& o, int posn):	heap<T>::handle(f, o, e), ind(posn)		{	}  // constructortemplate<class T>array_heap<T>::a_node& array_heap<T>::a_node::operator=(const a_node& a)	{	ind = a.ind ;	return *this ;	} // op=// ARRAY_HEAP METHODStemplate<class T>array_heap<T>::array_heap(less f, order o, int c): heap<T>(f, o)	{   array = new a_node*[c] ;   max_size = c ;//   for (int i=0; i<c; i++)//   	cout << array[i] << endl ;//   cout << max_size << endl ;	} // constructortemplate<class T>array_heap<T>::array_heap(const array_heap<T>& H): heap<T>(H)	{	array = new a_node*[H.max_size] ;	for ( int i = 0 ; i < H.size() ; i++ )//		array[i] = H.array[i] ;		push(**H.array[i]) ;	max_size = H.max_size ;	}  // copy constructortemplate<class T>array_heap<T>& array_heap<T>::operator=(const array_heap<T>& H)	{	heap<T>::operator=(H) ;	for ( int i = 0 ; i < size() ; i++ )		delete array[i] ;	delete [] array ;	array = new a_node*[H.max_size] ;	for ( int j = 0 ; j < H.size() ; j++ )//		array[i] = H.array[i] ;		push(**H.array[j]) ;	max_size = H.max_size ;	return *this;	} // op=template<class T>array_heap<T>::~array_heap()	{	for ( int i = 0 ; i < size() ; i++ )		delete array[i] ;	delete [] array ;	} // destructortemplate<class T>void array_heap<T>::swap(heap<T>::handle& h1, heap<T>::handle& h2)	{// cout << "*h1=" << *h1 << "  *h2=" << *h2 << " - swapping:" << endl ;	h1.swap(h2) ;  //   cout << "*h1=" << *h1 << "  *h2=" << *h2 << " - casting: " << endl ;	a_node& a1 = static_cast<a_node&>(h1) ;	a_node& a2 = static_cast<a_node&>(h2) ;//     cout << "*a1=" << *a1 << "  *a2=" << *a2 << endl ;//   int temp = a1.ind ;//	a1.ind = a2.ind ;//	a2.ind = temp ;//	  cout << "values for a1 and a2: " << endl ;//     cout << "a1.ind=" << a1.ind << "  a2.ind=" << a2.ind << endl ;//     cout << "&a1=" << &a1 << "  &a2=" << &a2 << " - swapping a1/a2:" << endl ;//   a_node* temp_node = &a1 ;//   array[a1.ind] = &a2 ;//   array[a2.ind] = temp_node ;	a_node temp = *array[a1.ind];   *array[a1.ind] = *array[a2.ind];   *array[a2.ind] = temp ;//      cout << "a1.ind=" << a1.ind << "  a2.ind=" << a2.ind << endl ;//     cout << "&a1=" << &a1 << "  &a2=" << &a2 << " - re-indexing:" << endl ;   for (int i=0; i<size(); i++)   	{(*array[i]).ind = i ;  }//       cout << "(*array[" << i << "]).ind=" << (*array[i]).ind << endl ;  }	} // swap()template<class T>int array_heap<T>::left(a_node a) const	{// cout << "a.indl: " << a.ind << "  size(): " << size() << "  empty(): " << empty() << endl ;	if ( empty() ) throw exception();	return (a.ind+1)*2-1 ;	} // left()template<class T>int array_heap<T>::right(a_node a) const	{//  cout << "a.indr: " << a.ind << "  size(): " << size() << "  empty(): " << empty() << endl ;	if ( empty() ) throw exception();	return (a.ind+1)*2 ;	} // right()template<class T>int array_heap<T>::parent(a_node a) const	{//   cout << "a.indp: " << a.ind << "  size(): " << size() << "  empty(): " << empty() << endl ;   if ( empty() ) throw exception();	return (a.ind+1)/2-1 ;  // because C++ arrays are 0..(n-1)	} // parent()template<class T>void array_heap<T>::sift_up(handle& h)	{ // cout << "sift-up \n\n" ;	a_node& a = static_cast<a_node&>(h) ;	int index = a.ind ;	while( index != 0 )   	{ // cout << "index= " << index ;      int paren = parent(*array[index]) ;      if ( (*array[index]).higher_priority(*array[paren]) )      	{  // cout << "paren= " << paren ;			swap(*array[index], *array[paren]) ;			index = paren ;	      } // cout << "index= " << index << "paren= " << paren ;		else break ;		}// re-index?	} // sift_uptemplate<class T>void array_heap<T>::sift_down(handle& h)	{ // cout << "sift_down \n\n " ;	a_node& a = static_cast<a_node&>(h);	int index = a.ind ;	while(true)		{ // cout << "index: " << index << "  last(): " << last() << endl ;	      if ( left(*array[index]) > last() ) break ;	      int hpchild ;	      if ( right(*array[index]) > last() )	      	hpchild = left(*array[index]) ;	      else	      	hpchild = (*array[left(*array[index])]).higher_priority(*array[right(*array[index])])            ? left(*array[index]) : right(*array[index]) ;	      if ( (*array[hpchild]).higher_priority(*array[index]) )	      	{				swap(*array[hpchild], *array[index]) ;				index = hpchild ;		      }			else  break;		} // while	} // sift_down()template<class T>heap<T>::handle&  array_heap<T>::create_new(const T& e)	{	if ( size() >= max_size ) throw exception() ;	array[size()] = new a_node(e, lt, ordering, size()) ;	return *array[size()] ;	} // create_new(): ONLY used in push()template<class T>heap<T>::handle&  array_heap<T>::first()	{	if ( empty() ) throw exception() ;	return *array[0] ;	} // first(): reference to first elementtemplate<class T>int array_heap<T>::last() const	{	if ( empty() || size() > max_size ) throw exception() ;	return (size()-1) ;	} // last(): index of the current last elementtemplate<class T>void array_heap<T>::move_last_to_first()	{   int lastint = last(); //  cout << "  lastint= " << lastint ;   swap(*array[0], *array[lastint]) ;  } // move_last_to_first(): ONLY used in pop()template<class T>void array_heap<T>::delete_last()	{	if ( empty() ) throw exception() ;	delete array[last()] ;	} // delete_last(): ONLY used in pop()template<class T>heap<T>::handle&  array_heap<T>::index(const heap<T>::handle& h) const	{	const a_node& a = dynamic_cast<const a_node&>(h);	return *array[a.ind] ;	} // index()template<class T>const T& array_heap<T>::top() const	{	if ( empty() ) throw exception();	return **array[0];	} // top()template<class T>void array_heap<T>::print(ostream& os, const array_heap<T>::a_node* n, int k = 0) const	{	for (int i = 0 ; i < k ; ++i)		{ cout << "   " ; }	cout << **n << "   ( this=" << (void*)n << ", l=" << array[left(*n)]   		<< ", r=" << array[right(*n)]			<< ", p=" << array[parent(*n)] << ')' <<  endl ;	if (left(*n) <= last()) print(os, array[left(*n)], k+1) ;   	else { for (int i = 0 ; i < k+1 ; ++i) cout << "   " ;			    os << '.'  << endl ; }	if (right(*n) <= last()) print(os, array[right(*n)], k+1) ;   	else { for (int i = 0 ; i < k+1 ; ++i) cout << "   " ;				 os << '.' << endl ; }	} // print()template<class T>void array_heap<T>::print(ostream& os) const	{	os << "First = " << array[0] << "   Last = " << array[last()] << endl ;	print(os, array[0]) ;	} // print()