// FILE: aheap.cpp// NAME:  Mark Sattolo// STUDENT #:  428500// SECTION:  CSI 2172A// MARKING SECTION:  A4     #if defined(__GNUG__)#pragma implementation#endif#include "aheap.h"// A_NODE METHODStemplate<class T>array_heap<T>::a_node::a_node(const T& e, heap<T>::less& f, heap<T>::order& o, int posn):	heap<T>::handle(f, o, e), ind(posn)		{	}  // constructor: array_heap's ind variable will record its position in the arraytemplate<class T>array_heap<T>::a_node& array_heap<T>::a_node::operator=(const a_node& a)	{	ind = a.ind ;	return *this ;	} // op=: assign the ind variable// ARRAY_HEAP METHODStemplate<class T>array_heap<T>::array_heap(less f, order o, int c): heap<T>(f, o),							     array(new a_node*[c]), max_size(c)	{	} // constructor: create the array and store its sizetemplate<class T>array_heap<T>::array_heap(const array_heap<T>& H): heap<T>(H)	{	array = new a_node*[H.max_size] ;	for ( int i = 0 ; i < H.size() ; i++ )		push(**H.array[i]) ;	max_size = H.max_size ;	}  // copy constructor: create a copy of the array elementstemplate<class T>array_heap<T>& array_heap<T>::operator=(const array_heap<T>& H)	{	heap<T>::operator=(H) ;	for ( int i = 0 ; i < size() ; i++ )		delete array[i] ;	delete [] array ;	array = new a_node*[H.max_size] ;	for ( int j = 0 ; j < H.size() ; j++ )		push(**H.array[j]) ;	max_size = H.max_size ;	return *this;	} // op=: destroy the old array and copy the newly-assigned onetemplate<class T>array_heap<T>::~array_heap()	{	for ( int i = 0 ; i < size() ; i++ )		delete array[i] ;	delete [] array ;	} // destructor: have to delete the array elements as they were dynamically allocatedtemplate<class T>void array_heap<T>::swap(heap<T>::handle& h1, heap<T>::handle& h2)	{	h1.swap(h2) ;	a_node& a1 = static_cast<a_node&>(h1) ;	a_node& a2 = static_cast<a_node&>(h2) ;	a_node temp = *array[a1.ind];   *array[a1.ind] = *array[a2.ind];   *array[a2.ind] = temp ;   for (int i=0; i<size(); i++)   	(*array[i]).ind = i ;  	} // swap(): swap the positions of two a_nodes -- used in sift_up() and sift_down()template<class T>int array_heap<T>::left(int a) const	{	if ( empty() ) throw exception();	return (a+1)*2-1 ;	} // left(): find the array index of the left childtemplate<class T>int array_heap<T>::right(int a) const	{	if ( empty() ) throw exception();	return (a+1)*2 ;	} // right(): find the arry index of the right childtemplate<class T>int array_heap<T>::parent(int a) const	{   if ( empty() ) throw exception();	return (a+1)/2-1 ;	} // parent(): find the array index of the parent nodetemplate<class T>void array_heap<T>::sift_up(handle& h)	{	a_node& a = static_cast<a_node&>(h) ;	int son = a.ind ;	while( son != 0 )   	{      int dad = parent(son) ;      if ( (*array[son]).higher_priority(*array[dad]) )      	{			swap(*array[son], *array[dad]) ;			son = dad ;	      }		else break ;		}	} // sift_up: move child node up the array if it is higher priority than its parenttemplate<class T>void array_heap<T>::sift_down(handle& h)	{	a_node& a = static_cast<a_node&>(h);	int upper = a.ind ;	while(true)		{	      if ( left(upper) > last() ) break ;  // no children	      int hpchild ;	      if ( right(upper) > last() )	      	hpchild = left(upper) ;  // if no right then highest priority is left child	      else	      	hpchild = (*array[left(upper)]).higher_priority(*array[right(upper)])            ? left(upper) : right(upper) ;  // find highest priority child	      if ( (*array[hpchild]).higher_priority(*array[upper]) ) // swap node and child if child is higher priority	      	{				swap(*array[hpchild], *array[upper]) ;				upper = hpchild ;		      }			else  break;		} // while	} // sift_down(): continually move a node down if it is lower priority than its highest priority childtemplate<class T>heap<T>::handle&  array_heap<T>::create_new(const T& e)	{	if ( size() >= max_size ) throw exception() ;	array[size()] = new a_node(e, lt, ordering, size()) ;	return *array[size()] ;	} // create_new(): used in heap::push()template<class T>heap<T>::handle&  array_heap<T>::first()	{	if ( empty() ) throw exception() ;	return *array[0] ;	} // first(): reference the first elementtemplate<class T>int array_heap<T>::last() const	{	if ( empty() || size() > max_size ) throw exception() ;	return (size()-1) ;	} // last(): index of the current last elementtemplate<class T>void array_heap<T>::move_last_to_first()	{  swap(*array[0], *array[last()]) ;  } // move_last_to_first(): used in heap::pop()template<class T>void array_heap<T>::delete_last()	{	if ( empty() ) throw exception() ;	delete array[last()] ;	} // delete_last(): ONLY used in heap::pop()template<class T>heap<T>::handle&  array_heap<T>::index(const heap<T>::handle& h) const	{	const a_node& a = dynamic_cast<const a_node&>(h);	return *array[a.ind] ;	} // index(): used in heap::priority_change()template<class T>const T& array_heap<T>::top() const	{	if ( empty() ) throw exception();	return **array[0];	} // top(): get the value at the top of the arraytemplate<class T>void array_heap<T>::print(ostream& os, const array_heap<T>::a_node* n, int k = 0) const	{	for (int i = 0 ; i < k ; ++i) os << "   " ; 	os << **n << "   ( this=" << (void*)n << ", l=" << array[left((*n).ind)]   		<< ", r=" << array[right((*n).ind)] << ", p=" << array[parent((*n).ind)] << ')' <<  endl ;	if ( left((*n).ind) <= last() )     		print(os, array[left((*n).ind)], k+1) ;   	else 		{		for (int i = 0 ; i < k+1 ; ++i) os << "   " ;		os << '.'  << endl ;		 }	if (right((*n).ind) <= last()) 		print(os, array[right((*n).ind)], k+1) ;   	else 		{		for (int i = 0 ; i < k+1 ; ++i) os << "   " ;		os << '.' << endl ; 		}	} // print(): recursively print a node and all its sub-nodestemplate<class T>void array_heap<T>::print(ostream& os) const	{	os << "First = " << array[0] << "   Last = " << array[last()] << endl ;	print(os, array[0]) ;	} // print(): print the first and last node addresses then print the array