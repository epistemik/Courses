ASSIGNMENT #1Read the general rules about submitting course work! Also read ``how can Imake my marker's life easier'' and ``what if my code does not compile?''.Due date:  /*  TUESDAY, OCTOBER 12, 1999	*/----------------------------------------------------------------------------Question #1 [ 100 marks ]Part A [ 10 marks ]     Implement a function with prototype          void me(ostream& os)     which prints the following information about you on the output stream os:        o name        o student number        o course code and marking section             For example, a call to this function me(cout) should produce something like:          name: Santa Claus          number: 123456          section: CSI2172 A2     of course, with your name, student number and marking section.     You should place the prototype of this function into the header file me.h and the implementation     of me into the file me.cpp.  There should be no other prototypes or functions (not even main) in     me.h and me.cpp. These two files will be linked with each of your assignments and will print this     information on the console for each question.Part B [ 50 marks ]     For this part, you will have to implement a number of functions dealing with arrays.      None of these functions require more than a few (at most 10) lines of code, most are even      much shorter than that. The aim of this exercise is to familiarize yourself with some C++      syntax and to learn about arrays, pointers and dynamic memory allocation.     A correct implementation of each of the following functions is worth 5 marks     int min(const int * a, int l)          calculates the minimum of array a which is of length l. If l is          zero, an ass1_exception is thrown. You may use any kind of loop or recursion!     int max(const int * a, int l)          calculates the maximum of array a which is of length l. If l is          zero, an ass1_exception is thrown. max must be recursive!     int* vector_alloc(int n)          returns the address of a dynamically allocated -- allocated by new[] -- vector which           contains n integers (do not initialize them!).           This function is really just a wrapper for the new[] operator.     void vector_dealloc(int*& v)          deallocates vector v using delete [] and sets v to 0. Also answer          in a comment line of your implementation why v is passed by reference!     int** matrix_alloc(int n, int m)          allocates an n x m matrix dynamically and returns its address.          matrix_alloc must use vector_alloc to allocate the n rows!     void matrix_dealloc(int**& a, int n)          deallocates matrix a which has n rows and sets a to 0. Also answer          in a comment line of your implementation why there is no need for the number of columns!     int* vector_copy(const int* v, int l)          creates a carbon copy of vector v. Fist it allocates a new vector          of length l using vector_alloc and then it copies the elements.          The address of this new vector is returned.     int** matrix_copy(const int* const * M, int n, int m)          creates a carbon copy of matrix M which has n rows and m columns.          The new matrix is dynamically allocated and the elements of M are          copied. The address of this new matrix is returned.          note:                    const int * const *                      |     			  |                      |           		  |            This const is         This const is            for the elements   for each row            of the rows     void vector_print(ostream& os, const int* v, int l)          prints vector v on the output stream os. v is of length l. The          vector is enclosed in a pair of curly braces ({ and }) and the elements are comma separated.           For example:          					{1,2,3,4,5}     void matrix_print(ostream& os, const int * const * M, int n, int m)          prints matrix M which has n rows and m columns on the output stream os.           The matrix is enclosed in a pair of curly braces and the rows are comma separated.           The rows themselves are printed by vector_print. For example:                  {                    {1,2,3,4},                    {3,2,0,1},                    {5,6,0,2}                  }The prototypes of these functions must be in the file called ass1.h (itis already typed in for you!). The implementation of these files must be in the file called ass1.cpp.Part C [ 20 marks ]	For this part you will implement four functions which are a bit more interesting.     [ 8 marks ]     void quick_sort(int* v, int l, int h)          the well known quick sort algorithm partitions the vector v into two parts: one where           the elements are smaller and one where the elements are bigger or equal to a pivot value           chosen from the vector. It is often convenient to select the first or the last element as pivot.           Then these two parts are sorted recursively.  See the pseudo code and a trace!           Lab 7 also has a generic version of quick_sort already typed in (notes page 169).     [ 6 marks ]     int* apply(int** M, int n, int m, int (*f) (const int*, int))          M is an n x m matrix of integers and f is a function which returns an int and takes a vector           and its length as arguments.  'apply' simply executes f on each end every row of M and records           the results in a dynamically allocated vector of length n and returns its address. For example:            int sum(const int* v, int l) {               int s = 0;               for(int i=0; i < l; i++) { s += v[i]; }               return s;            }            // M = { { 1, 2, 3, 0},            //       {-1, 1, 2,-1},            //       { 0, 6, 0, 1} };            ...            v = apply(M,3,4,sum);                // v == { 6, 1, 7 }                // ie sum of each row     [ 4 marks ]     int matrix_max(const int* const* M, int n, int m)          M is an n x m matrix of integers. matrix_max returns the maximum element of M,           this function must make use of functions apply and max!     [ 2 marks ]     void matrix_sort(int** M, int n, int m)          M is an n x m matrix of integers. This function simply calls quick_sort on every row of M.The prototypes of these functions must in the file called ass1.h (it is already typed in for you!). The implementation of these files must be in the file called ass1.cpp.Part D [ 20 marks ]     Write a test program which tests every function you implemented. In particular, main as its      first line must call              me(cout);     which identifies you on the console. You do not have to specifically test those functions which      are called by others.  For example, vector_print should be called by matrix_print, hence it is      enough to test matrix_print. You may enter data from the console, but you do not have to!      You may have variables instantiated in the code, like:       ...       int ** M = matrix_alloc(3,4);       M[0][0] = 1; M[0][1] = 2; M[0][2] = 3; M[0][3] = 4;       M[1][0] =-1; M[1][1] = 4; M[1][2] = 0; M[1][3] = 0;       M[2][0] = 0; M[2][1] = 0; M[2][2] =-2; M[2][3] = 1;       ...     Make sure that there is enough info printed on the console for the marker so he or she can easily      follow what your test program is doing.  The functions you implemented for part B and part C      should not print to the console (ie cout). Main, on the other hand, should write to the console!     This test program which calls all your functions (explicitly or implicitly) must be implemented      in the file called test.cpp.***********************************************************************Bonus [ 20 marks ]     This is a bonus question. In other words, you may achieve 100% on this assignment without      touching this question. The effort required to earn this 20 marks is more than earning 20 marks      on the previous questions.     This question tests your knowledge on pointers and arrays.  We have seen how multi-dimensional      arrays are allocated in C++ (notes page 43, page 58).  Just by the very nature of this technique,      multi-dimensional arrays are not forced to take rectangular shape in n dimensions.     Moreover, a multi-dimensional array can also have aliasing within the structure itself.      In other words, some of the pointers may actually point to the very same physical array!     Imagine the following structure:                                     [Image]     This structure has a number of interesting properties. It has 2n-1 rows and the longest row is      n elements while the shortest row has one element.  The first row is also physically the same      as the last row and the second row is physically the same as the second last row.      In general, the ith row is physically the same as the (2n-1-i)th row.      This is illustrated on the second figure; after the assignments:           A[0][0] = 10;           A[1][1] = -3;           A[0][2] =  0;     The values of A[6][0], A[5][1] and A[6][2] have changed as well.     [ 10 marks ]          Draw the layout in memory of the 7x4 structure depicted above.  Feel free to make up           addresses but make sure that those parts which must be adjacent are adjacent and those           which may not be are not adjacent on your diagram. Also indicate the value of each slot in           the array -- whether it is an address or an integer. Assume 4 byte pointers and 2 byte integers!           The diagram should be similar to the one in your notes on page 58. You do not have to use a          drawing package but do use a ruler and be neat.     [ 10 marks ]          Implement the following three functions:          [ 4 marks ]          int ** allocate(int n)               which allocates the 2n-1 x n structure discussed above. If n == 0 then the address 0x0000                (NULL) is returned.  This function also initializes the elements of the structure, as shown                on the figure. The elements of the first row are 10n + 1, 10n + 2 .... 10n + n. The elements                of the second row are 10(n-1) + 1 ... 10(n-1) + n-1 and in general if k <= n then the elements                of the kth row are 10(n-k+1) + 1 ... 10(n-k+1) + (n-k+1). As the rows below the nth row                are physically the same as some row above, they are automatically initialized.          [ 3 marks ]          void print(ostream& os, int** M, int n)               prints the 2n-1 x n structure M on the output stream os. For the structure depicted above                the output would be:                 41 42 43 44                 31 32 33                 21 22                 11                 21 22                 31 32 33                 41 42 43 44          [ 3 marks ]          void deallocate(int**& M, int n)               deallocates all dynamic memory associated with the 2n-1 x n  structure M and sets M to                hold the address 0x0000.The prototypes of the three functions must be in the header file bonus.h. The implementation of these functions must be in the file called bonus.cpp. The file which tests these functions must be called bonusmain.cpp. Feel free to use mine, because that is what the marker will use. This what the output should look like with my test program.**********************************************************************************What do I hand in???    A diskette with only the following files:        o me.h (Part A)        o me.cpp (Part A)        o ass1.h (Part B & C)        o ass1.cpp (Part B & C)        o test.cpp (Part D)    Printouts of only the following files:        o me.cpp        o ass1.cpp        o test.cpp    If you did the bonus, also have the following files on the diskette:        o bonus.h        o bonus.cpp        o bonusmain.cpp    A printout of bonus.cpp and your drawing of the memory layout.Absolutely nothing else! Do not have any other files on the diskette!  Those generated by Borland should be removed.  Do not hand in printouts of files not explicitly asked for!Good Luck!!!