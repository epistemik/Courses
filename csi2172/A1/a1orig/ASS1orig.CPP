// FILE:  ass1.cpp// NAME:  Mark Sattolo// STUDENT #:  428500// SECTION:  CSI 2172A// MARKING SECTION:  A4/* Part B [ 50 marks ]     For this part, you will have to implement a number of functions dealing with arrays.      None of these functions require more than a few (at most 10) lines of code, most are even      much shorter than that. The aim of this exercise is to familiarize yourself with some C++      syntax and to learn about arrays, pointers and dynamic memory allocation.     A correct implementation of each of the following functions is worth 5 marks	*/#include <iostream.h>#include "ass1.h"int min(const int *a, int l)	{	try 		{		if ( l == 1 )  return *a ;		else if ( l > 1 )				{				int temp = *a ;				int temp_min = min( ++a,  l - 1 ) ;				return temp_min < temp ? temp_min : temp ;				}			else if ( l == 0 ) throw ass1_exception() ;		}	catch ( ass1_exception e )		{		cout << "min Error:  array length " << l << " is not a possible value! " << endl ;		}	return -1 ;	}	/* min()		calculates the minimum of array a which is of length l. If l is zero, an ass1_exception 		is thrown.  You may use any kind of loop or recursion! */int max(const int *a, int l)	{	try 		{		if ( l == 1 )  return *a ;		else if ( l > 1 )				{				int temp = *a ;				int temp_max = max( ++a,  l - 1 ) ;				return temp_max > temp ? temp_max : temp ;				}			else if ( l == 0 ) throw ass1_exception() ;		}	catch ( ass1_exception e )		{		cout << "max Error:  array length " << l << " is not a possible value! " << endl ;		}	return -1 ;	}	/* max()		calculates the maximum of array a which is of length l. If l is zero, an ass1_exception 		is thrown.  max must be recursive! */int* vector_alloc(int n)	{	int* temp = new int[n] ;	return temp ;	}	/* vector_alloc()		returns the address of a dynamically allocated -- allocated by new[] -- vector which 		contains n integers	(do not initialize them!).  This function is really just a wrapper 		for the new[] operator. */void vector_dealloc(int*& v)	{	delete [] v ;	v = 0 ;	}	/* vector_dealloc()		deallocates vector v using delete [] and sets v to 0. Also answer		in a comment line of your implementation why v is passed by reference! */int** matrix_alloc(int n, int m)	{	int** temp = new int* [n] ;	for ( int i = 0 ; i < n ; i++ )		temp[i] = vector_alloc( m ) ;	return temp ;	}	/* matrix_alloc()		allocates an n x m matrix dynamically and returns its address.		matrix_alloc must use vector_alloc to allocate the n rows! */void matrix_dealloc(int**& a, int n)	{	for ( int i = 0 ; i < n ; i++ )		vector_dealloc( a[i] ) ;	a = 0 ;	}	/* matrix_dealloc()		deallocates matrix a which has n rows and sets a to 0.  Also answer in a comment 		line of your implementation why there is no need for the number of columns! */int* vector_copy(const int* v, int l)	{	int* temp = vector_alloc( l ) ;	for ( int i = 0 ; i < l ; i++ )		{		temp[i] = v[i] ;		//temp++ ;		//v++ ;		}	return temp ;	}	/* vector_copy()		creates a carbon copy of vector v.  First it allocates a new vector of length l using 		vector_alloc and then it copies the elements.  The address of this new vector is returned. */int** matrix_copy(const int* const * M, int n, int m)	{	int** temp = matrix_alloc( n, m ) ;	for ( int i = 0 ; i < n ; i++ )		for ( int j = 0 ; j < m ; j++ )			temp[i][j] = M[i][j] ;	return temp ;	}	/* matrix_copy		creates a carbon copy of matrix M which has n rows and m columns.		The new matrix is dynamically allocated and the elements of M are copied. 		The address of this new matrix is returned.		note:                    const int * const *                      |     			  |                      |           		  |            This const is         This const is            for the elements   for each row            of the rows								*/void vector_print(ostream& os, const int* v, int l)	{	os << "{ " ;	for ( int i = 1 ; i <= l ; i++ )		{		os << *v ;		if ( i < l ) os << ", " ;		v++ ;		}	os << " }" ;	}	/* vector_print()		prints vector v on the output stream os. v is of length l. The vector is enclosed 		in a pair of curly braces ({ and }) and the elements are comma separated.		For example:							{1,2,3,4,5}		*/void matrix_print(ostream& os, const int * const * M, int n, int m)	{	os << "  {" << endl ;	for ( int i = 1 ; i <= n ; i++ )		{		os << "\t" ;		vector_print( os, *M, m ) ;		if ( i < n ) os << ", " ;		os << endl ;		*M++ ;		}	os << "  }" << endl ;	}	/* matrix_print		prints matrix M which has n rows and m columns on the output stream os. 		The matrix is enclosed in a pair of curly braces and the rows are comma separated. 		The rows themselves are printed by vector_print. 		For example:							{							  {1,2,3,4},							  {3,2,0,1},							  {5,6,0,2}							}				*//*The prototypes of these functions must be in the file called ass1.h (it is already typed in for you!). The implementation of these files must be in the file called ass1.cpp.Part C [ 20 marks ]     For this part you will implement four functions which are a bit more interesting.	*///[ 8 marks ]void quick_sort(int* v, int l, int h)	{	if ( l < h )		{		int i = l ; int j = h ;		int Pivot = *( v + ( (i + j) / 2 ) ) ;	// set Pivot to middle value		do {			while ( v[i] < Pivot )  i++ ;		// move i forward			while ( v[j] > Pivot )  j-- ;		// move j backward			if ( i <= j )				{				int temp = v[i]; v[i] = v[j]; v[j] = temp ; // swap v[i] & v[j]				i++ ;  j-- ;		// update indices				}			} while (i <= j) ;		// continue until i and j cross 		// sort the two halves recursively 		quick_sort( v, l, j ) ;		quick_sort( v, i, h ) ;		}	}	/* quick_sort()		the well known quick sort algorithm partitions the vector v into	two parts: 		one where the elements are smaller and one where the elements are bigger or equal		to a pivot value chosen from the vector.  It is often convenient to select the first or the last		element as pivot.  Then these two parts are sorted recursively.  See the pseudo code and 		a trace!  Lab 7 also has a generic version of quick_sort already typed in (notes page 169) *///[ 6 marks ]int* apply(int** M, int n, int m, int (*f) (const int*, int))	{	int* result = vector_alloc( n ) ;	for ( int i = 0 ; i < n ; i++ )		{		result[i] = f( M[i], m ) ;		//result++ ;		//(*M)++ ;		}	return result ;	}	/* apply()		M is an n x m matrix of integers and f is a function which returns an int and takes a 		vector and its length as arguments.  apply	simply executes f on each end every row of M 		and records the results in a dynamically allocated vector of length n and returns its address.		For example:            int sum(const int* v, int l) {               int s = 0;               for(int i=0; i < l; i++) { s += v[i]; }               return s;            }            // M = { { 1, 2, 3, 0},            //       {-1, 1, 2,-1},            //       { 0, 6, 0, 1} };            ...            v = apply(M,3,4,sum);                // v == { 6, 1, 7 }                // ie sum of each row		*///[ 4 marks ]int matrix_max(const int* const* M, int n, int m)	{	int** M_temp = const_cast<int**>( M ) ;	int* result = vector_alloc( n ) ;	result = apply( M_temp, n, m, max ) ;	int temp = max( result, n ) ;	vector_dealloc(result) ;	return temp ;	}	/* matrix_max()		M is an n x m matrix of integers.  matrix_max returns the maximum element of M, 		this function must make use of functions apply and max! *///[ 2 marks ]void matrix_sort(int** M, int n, int m)	{	for ( int i = 0 ; i < n ; i++ )		{		quick_sort( M[i], 0, m-1 ) ;		//(*M)++ ;		}	}	/* matrix_sort()		M is an n x m matrix of integers. This function simply calls quick_sort on every row of M. *//*The prototypes of these functions must in the file called ass1.h (it is already typed in for you!). The implementation of these files must be in the file called ass1.cpp.*/