/* FILE:  bonus.cpp NAME:  Mark Sattolo STUDENT #:  428500 SECTION:  CSI 2172A MARKING SECTION:  A4     ASSIGNMENT #1Bonus [ 20 marks ]     This is a bonus question. In other words, you may achieve 100% on this     assignment without touching this question. The effort required to earn     this 20 marks is more than earning 20 marks on the previous questions.     This question tests your knowledge on pointers and arrays. We have seen     how multi-dimensional arrays are allocated in C++ (notes page 43, page     58). Just by the very nature of this technique, multi dimensional     arrays are not forced to take rectangular shape in n dimensions.     Moreover, a multi dimensional array can also have aliasing within the     structure itself. In other words, some of the pointers may actually     point to the very same physical array!     Imagine the following structure:                                     [Image]     This structure has a number of interesting properties. It has 2n-1 rows     and the longest row is n elements while the shortest row has one     element. The first row is also physically the same as the last row and     the second row is physically the same as the second last row. In     general, the ith row is physically the same as the (2n-1-i)th row. This     is illustrated on the second figure; after the assignments:           A[0][0] = 10;           A[1][1] = -3;           A[0][2] =  0;     The values of A[6][0], A[5][1] and A[6][2] have changed as well.     [ 10 marks ]          Draw the layout in memory of the 7x4 structure depicted above.          Feel free to make up addresses but make sure that those parts          which must be adjacent are adjacent and those which may not be are          not adjacent on your diagram. Also indicate the value of each slot          in the array -- whether it is an address or an integer. Assume 4          byte pointers and 2 byte integers! The diagram should be similar          to the one in your notes on page 58. You do not have to use a          drawing package but do use a ruler and be neat.     [ 10 marks ]          Implement the following three functions:		*/#include <iostream.h>#include <math.h>	// to use function abs()// [ 4 marks ] int ** allocate(int n)	{	if ( n == 0 ) return NULL ;	else		{		int ** M = new int* [2*n-1] ;		for ( int i = 0 ; i < n ; i++ ) 			{			M[i] = new int[n-i] ;			for ( int k = 0 ; k < n-i ; k++ ) M[i][k] = 10*(n-i) +k + 1 ;			}		for ( int j = n ; j < 2*n-1 ; j++) M[j] = M[2*n-j-2] ;		return M ;		}	}	/* Allocates the 2n-1 x n structure discussed above.  If n == 0 then the address 0x0000 	(NULL) is returned.  This function also initializes the elements of the structure, as shown 	on the figure.  The elements of the first row are 10n + 1, 10n + 2 .... 10n + n.  The elements 	of the second row are 10(n-1) + 1 ... 10(n-1) + n-1 and in general if k <= n then the elements 	of the kth row are 10(n-k+1) + 1 ... 10(n-k+1) + (n-k+1).  As the rows below the nth row are 	physically the same as some row above, they are automatically initialized. */// [ 3 marks ] void print(ostream& os, int** M, int n) 	{ 	for ( int i = 0 ; i < 2*n-1 ; i++ )		{		for ( int j = 0 ; j < (abs(n-1-i)+1) ; j++ )			os << M[i][j] << " " ;		os << endl ;		}	}      /* prints the 2n-1 x n structure M on the output stream os.  For the structure depicted       above the output would be:        41 42 43 44        31 32 33        21 22        11        21 22        31 32 33        41 42 43 44	*/// [ 3 marks ] void deallocate(int**& M, int n) 	{ 	for ( int k = 0 ; k < n ; k++ ) delete [] M[k] ; 	delete [] M ; 	M = NULL ; 	}      /* deallocates all dynamic memory associated with the 2n-1 x n structure M and sets M       to hold the address 0x0000.The prototypes of the three functions must be in the header file bonus.h. The implementation of these functions must be in the file called bonus.cpp. The file which tests these functions must be called bonusmain.cpp. Feel free to use mine, because that is what the marker will use.	*/