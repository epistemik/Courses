// FILE:  ass1.h// NAME:  Mark Sattolo// STUDENT #:  428500// COURSE:  CSI 2172A// MARKING SECTION:  A4#if ! defined( _ASS1_H_ )#define _ASS1_H_#include <iostream.h>	class ass1_exception // declare the exception class for functions max and min		{  } ;	int min(const int * a, int l) ;          /* calculates the minimum of array a which is of length l. If l is zero,           an ass1_exception is thrown. You may use any kind of loop or recursion! */          	int max(const int * a, int l) ;          /* calculates the maximum of array a which is of length l. If l is zero,           an ass1_exception is thrown. max must be recursive! */	int* vector_alloc(int n) ;          /* returns the address of a dynamically allocated -- allocated by new[] -- vector which           contains n integers (do not initialize them!).           This function is really just a wrapper for the new[] operator. */	void vector_dealloc(int*& v) ;          /* deallocates vector v using delete [] and sets v to 0. Also answer          in a comment line of your implementation why v is passed by reference! */	int** matrix_alloc(int n, int m) ;          /* allocates an n x m matrix dynamically and returns its address.          matrix_alloc must use vector_alloc to allocate the n rows! */	void matrix_dealloc(int**& a, int n) ;          /* deallocates matrix a which has n rows and sets a to 0.  Also answer in a comment          line of your implementation why there is no need for the number of columns! */	int* vector_copy(const int* v, int l) ;          /* creates a carbon copy of vector v.  Fist it allocates a new vector of length l using           vector_alloc and then it copies the elements.  The address of this new vector is returned. */	int** matrix_copy(const int* const * M, int n, int m) ;          /* creates a carbon copy of matrix M which has n rows and m columns.          The new matrix is dynamically allocated and the elements of M are copied.          The address of this new matrix is returned.	*/	void vector_print(ostream& os, const int* v, int l) ;          /* prints vector v on the output stream os. v is of length l. The          vector is enclosed in a pair of curly braces ({ and }) and the elements are comma separated. */	void matrix_print(ostream& os, const int * const * M, int n, int m) ;          /* prints matrix M which has n rows and m columns on the output          stream os. The matrix is enclosed in a pair of curly braces and          the rows are comma separated. The rows themselves are printed by vector_print.The prototypes of these functions must be in the file called ass1.h (it is already typed in for you!). The implementation of these files must be in the file called ass1.cpp.Part C [ 20 marks ]     For this part you will implement four functions which are a bit more interesting.		*///     [ 8 marks ]	void quick_sort(int* v, int l, int h) ;//     [ 6 marks ]	int* apply(int** M, int n, int m, int (*f) (const int*, int)) ;//     [ 4 marks ]	int matrix_max(const int* const* M, int n, int m) ;          /* M is an n x m matrix of integers. matrix_max returns the maximum          element of M, this function must make use of functions apply and max! *///     [ 2 marks ]	void matrix_sort(int** M, int n, int m) ;          /* M is an n x m matrix of integers. This function simply calls quick_sort           on every row of M.  */          #endif