// FILE:  main.cpp// NAME:  Mark Sattolo// STUDENT #:  428500// SECTION:  CSI 2172A// MARKING SECTION:  A4     #include <iostream>#include <strstream>#include <fstream>#include "lexer.h"#include "qsort.h"#include "me.h"#include <string.h>#include "circle.h"#include "triangle.h"#include "square.h"#include "rectangle.h"bool smaller(shape* const& s1, shape* const& s2)	{  return s1->area() < s2->area() ;  } // used by function quick_sortint main(int argc, char* argv[]) // shape tokens will be entered on the command line{    me(cout) ;// add all the existing shape_instantiators to the "instantiators" array of class shape   shape::add_instantiator(new circle_instantiator()) ;   shape::add_instantiator(new triangle_instantiator()) ;   shape::add_instantiator(new square_instantiator()) ;   shape::add_instantiator(new rectangle_instantiator()) ;   int n = argc - 1; // current size of "instantiators"   shape** array = new shape*[n]; // will fill array with the shapes in the stream   for ( int i =1 ; i <= n ; ++i ) 	{	lexer sL;	istrstream string_stream(argv[i], strlen(argv[i])); // the stream is string stream argv[i]	try {	        // read() will identify which particular shape_instantiator to use and 	        // instantiate that shape, returning a reference we will store in array	        array[i-1] = shape::read(string_stream, sL);	        if (array[i-1] == 0) throw "";	      }	catch (...)		   {  // exit if an unknown object on the stream		        cout << "I do not understand \'" << argv[i] << "\'" << endl;		        shape::remove_instantiators();		        return 1;		      }	} //  for   quick_sort<shape*>(array, 0, n-1, smaller); // sort "array"// write each of the instantiated objects to file "shapes.txt"   ofstream os("shapes.txt");   for(int i=0; i<n; ++i) 	{	 os << *(array[i]) <<  "  # area: " << array[i]->area() << endl;	 delete array[i];	}// free the dynamic memory of array and close the output stream of "shapes.txt"   delete [] array;   os.close();// now use "shapes.txt" as an input stream and use the read() method to identify // the shapes in this file, then output them to the console	ifstream is("shapes.txt") ;	lexer L ;	while(true)	{	 shape* s;	 try { s = shape::read(is, L) ; }	 catch (...) { cout << "could not read shape" << endl;						is.close();						shape::remove_instantiators();						return 1;					 }	 if (s == 0) break ;	 cout << *s << "  has area: " << s->area() << endl;	 delete s ;	} //  while// close the stream and free any remaining dynamic memory before ending	is.close();	shape::remove_instantiators();	return 0;}