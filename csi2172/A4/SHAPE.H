// FILE: shape.h// NAME:  Mark Sattolo// STUDENT #:  428500// SECTION:  CSI 2172A// MARKING SECTION:  A4#if !defined(_SHAPES_H_)#define _SHAPES_H_#include <iostream.h>#include "lexer.h"class shape{   private:	// shape keeps a list of all the particular shape_instantiators in the array "instantiators" ;	// the current size of the array and its maximum size are set in variables "n" and "capacity" ;	// these are all class variables: there will be just one array for all shapes      static class shape_instantiator** instantiators ;      static int capacity ;      static int n ;   public:	// shape has class methods to add a new instantiator, to delete the existing array,	// and to read an input stream for a shape object      static void add_instantiator(class shape_instantiator*) ;      static void remove_instantiators() ;      static shape* read(istream&, lexer&) ;	// print() and area() have to be implemented separately for each particular subclass of shape      virtual void print(ostream&) const = 0 ;      virtual double area() const = 0 ;};	// overload "<<" to have it print out shapesostream& operator<<(ostream&, const shape&);class shape_instantiator {   private:	// the different shape_instantiator subclasses are distinguished by having a different name string      char* name;   public:	// standard constructor, operator=, etc. to deal with the dynamic memory in char* name      shape_instantiator(const char* name);      shape_instantiator(const shape_instantiator&);      shape_instantiator& operator=(const shape_instantiator&);      virtual ~shape_instantiator();	// will use get_name() to see if an object has the same "name" as an instantiator      const char* get_name() const;	// instantiate() will have to be implemented by the individual subclasses      virtual shape* instantiate(istream&, lexer&) const = 0;}; #endif