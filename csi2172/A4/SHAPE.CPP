// FILE: shape.cpp// NAME:  Mark Sattolo// STUDENT #:  428500// SECTION:  CSI 2172A// MARKING SECTION:  A4#include "shape.h"#include <string.h>// initialize the variablesshape_instantiator** shape::instantiators = 0 ;int shape::n = 0 ;int shape::capacity = 0 ;// add a new shape_instantiator (e.g. "circle", "square") to array "instantiators"void shape::add_instantiator(shape_instantiator* ins) {   for(int i = 0 ; i < n ; ++i)       if (strcmp(ins->get_name(), instantiators[i]->get_name()) == 0) 		return; // this instantiator is already registered   if (n == capacity) // increase size of the array if necessary   	{	capacity += capacity/2 + 1 ;	shape_instantiator** new_instantiators = new shape_instantiator*[capacity] ;	for(int i = 0 ; i < n ; ++i) 		new_instantiators[i] = instantiators[i] ;	delete [] instantiators ;	instantiators = new_instantiators ;	}// add the new instantiator to the array   instantiators[n] = ins ;   ++n ;} // add_instantiator// destroy the "instantiators" arrayvoid shape::remove_instantiators() {   for(int i = 0 ; i < n ; ++i)    	delete instantiators[i] ;   delete [] instantiators ;}// read() uses helper class lexer to peek at a token from the stream, which should be a char*,// and compare it to the list of names in instantiators, to choose which particular // shape_instantiator will be invoked to actually read the stream object.// lexer puts the token back on the stream after checking it, so this char* can also be // checked by the actual instantiate() method.// read() will return 0 if EOF is reached or if the token is not in the array.shape* shape::read(istream& is, lexer& L) {   const char* token = L.next_token(is) ;   if (L.get_type() == LEX_EOF) return 0 ;   for(int i=0; i<n; ++i)    	{	if (strcmp(token,instantiators[i]->get_name()) == 0) 		// a match -- use this shape_instantiator to instantiate the stream object      		{      		L.putback() ;      		return instantiators[i]->instantiate(is,L) ;      		}   	}   // no match    L.putback() ;   return 0 ;} // read()shape_instantiator::shape_instantiator(const char* n): name(new char[strlen(n)+1]) 	{  strcpy(name,n) ;  } // set name in the constructor// copy constructor and assignment operator have to handle the dynamic memory in nameshape_instantiator::shape_instantiator(const shape_instantiator& i): name(new char[strlen(i.name)+1]) 	{  strcpy(name,i.name) ;  }shape_instantiator& shape_instantiator::operator=(const shape_instantiator& i) 	{	delete [] name ;	name = new char[strlen(i.name)+1] ;	strcpy(name,i.name) ;	return *this ;	}const char* shape_instantiator::get_name() const 	{  return name ;  }shape_instantiator::~shape_instantiator() 	{  delete [] name ;  } // destructor has to delete [] char* nameostream& operator<<(ostream& os, const shape& s) 	{	// call shape's print() method	s.print(os) ;	return os ;	}