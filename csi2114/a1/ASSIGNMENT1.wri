CSI 2114 Assignment 1 Summer 1999In this assignment, you will design a Turbo Pascal "unit" that implements a"collection" data structure. A collection, as its name implies, is the mostgeneral of all data structures. The type of collection you will implementbehaves like a big bag that holds everything you put in it withoutpreserving the order you put things in. In practice it could be implementedusing almost any type of data structure, but the easiest thing to do will beto use a linked list.Question 1. Use the type definitions and specifications below to write aPascal unit ("a1unit.pas") with the implementations for all the operationslisted below. Try to make your implementations as time-efficient as possible(hint: don't traverse a list unless you have to.) A separate test programwill compile using the unit to make sure everything works. See chapter 4 ofthe text for information on Pascal units. Borland Pascal for Windows alsohas a good help section (search for keyword "unit").Question 2. For each of the procedures you implement, state on a separatesheet of paper whether the operation is constant time O(k), linear timeO(n), or quadratic time O(n2), where n is the number of nodes in thecollection.Marking Scheme:  Code for question 1: Programming Standards for question 20  1:*                                20  Question 2                         10  -------------------------------------------- Total:                             50*Programming Standards covers the layout of the TPU file, comments, andindenting.Type Definitions:To be included in the "interface" section of the file"a1unit.pas".(********************** TYPE DEFINITIONS ***************************)type(*Collection_element = the data type to store in the collection *)   collection_element = string;(*Collection_node = a node in the linked list storing the collectionelements *)   collection_node_pointer = ^collection_node;   collection_node = record      value: collection_element;      next: collection_node_pointer;   end;(*Collection_header = a record containing information about the size of thecollection, as well as pointers to the first and last elements *)   collection_header = record      size: integer;      first: collection_node_pointer;      last: collection_node_pointer;   end;(*Collection = the main data type of the collection. It is a pointer to acollection header *)   collection = ^collection_header;Specifications:These headers should go in the "implementation" section of "a1unit.pas". Each header should be followed by your code to implement the operation.(* Create(C)   * preconditions: C is undefined   * postconditions: C is the empty collection with storage allocated as     needed. *)(* Destroy(C)   * preconditions: C is a defined collection   * postconditions: C' is undefined. All dynamically allocated memory *)(* Size(C)   * preconditions: C is a defined collection.   * postconditions: returns the number of elements in C. *)(* Is_Empty(C)   * preconditions: C is a defined collection.   * postconditions: returns true if C is empty, false otherwise. *)(* Insert(C,V)   * preconditions: C is a defined collection, V is a collection element.   * postconditions: C has value V added. Storage is allocated as needed. If     V already occurs in C an additional copy is added. *)(* Delete(C,V)   * preconditions: C is a defined collection, V is a collection element   * postconditions: C has the value V removed. If V occurs more than once,     only one occurrence is removed. If V does not occur in C, no change is     made. *)(* Join(C1,C2)   * preconditions: C1 and C2 are two different defined collections.   * postconditions: C1 is the union of the two collections (i.e. it     contains all the elements originally in C1 and C2). C2 is undefined. *)(* Print(C1)   * preconditions: C1 is a defined collection.   * postconditions: The elements in C1 are printed to the screen in any     order.  If C1 is empty, the message "EMPTY COLLECTION" is printed to     the screen. *)Memory ManagementThe following code will help you do memory management on the CollectionNodes.  Always use "Get_CNode" and "Return_CNode" instead of "new" and"dispose", and the "MemCount" variable will keep track of memory leaks foryou.  This code goes in the TPU file at the end - note the initializationsection.  You will also have to include the "Memcheck" function in theinterface section so it can be called from the main program.  Note thatthese functions only keep track of Collection Nodes.  Don't try to use themfor allocating the Collection Header.(***************** Special memory management stuff *******************)(* Place the following ABOVE the collection procedures and functions *)var MemCount: integer;(* Use Get_CNode instead of "new" *)procedure Get_CNode(var C: collection_node_pointer);begin   new(C);   MemCount := MemCount + 1;end;(* Use Return_CNode instead of "dispose" *)procedure Return_CNode(var C: collection_node_pointer);begin   dispose(C);   MemCount := MemCount - 1;end;function MemCheck: boolean;begin   MemCheck := (MemCount = 0);end;(******************** INITIALIZATION CODE **********************)(* this must be placed AT THE END of the TPU file.  If you want   to initialize other globals, you may do so by adding code to   this section *)begin   MemCount := 0;end.Hints and advice:Don't write any new code if you don't have to. The implementation specifiedin the type definitions is a linked-list implementation, so you should beable to paste in a lot of code from the 1101 assignments or assignmentsolutions. Of course you will have to modify the headers to use the typedefinitions "collection" and "collection_element", and possibly to deal withthe "last" pointer. You will also have to organize the code within a Pascalunit instead of within the main program file.For example, you have probably already written several types of "insert"procedures for linked lists. You can re-use this code for the "insert"procedure above, but you will have to change the parameters so that:          a. it takes a collection (pointer to a collection_header) rather          than a linked list (pointer to a list node).          b. it takes a collection_element as its value type          c. it updates both the first and last pointers if necessary.Final notes:   * Always follow the assignment guidelines.  Don't forget to include the     "IdentifyMyself" procedure in your TPU file.  You will have to make it     part of the interface too.   * Name your unit "a1unit.pas", and make sure the first line is "unit     a1unit;".  Failure to do this will cause errors.   * You should use the test program "a1test.pas" to test your unit, but     this program may not reveal all bugs, so make sure you test as     thoroughly as possible using your own code.  You will have to compile     your unit (F9 in Pascal for windows) before a1test.pas can run.   * Don't forget to hand in an executable file.  You can create one by     compiling "a1test.pas" using your unit to a file named "a1test.exe"   * Watch out for the parameters types.  Make sure you use VAR when you     need it and don't use VAR when you don't need it   * Make sure your unit is documented properly. Separate the sections     clearly using comments, and include the specifications in a header     before each procedure.  If there is anything special about your     implementation, make sure you note that in comments.   * Use clear and consistent indenting when you lay out the unit.