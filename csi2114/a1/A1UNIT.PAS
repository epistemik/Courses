UNIT  a1unit ;INTERFACE{ Type Definitions:  To be included in the "interface" section of the file"a1unit.pas". }type(*Collection_element = the data type to store in the collection *)	collection_element = string;(*Collection_node = a node in the linked list storing the collection elements *)	collection_node_pointer = ^collection_node;	collection_node =	record								value: collection_element;								next: collection_node_pointer;							end;(*Collection_header = a record containing information about the size of the collection,	as well as pointers to the first and last elements *)	collection_header = record								size: integer;								first: collection_node_pointer;								last: collection_node_pointer;							  end;(*Collection = the main data type of the collection. It is a pointer to a collection header *)	collection = ^collection_header;var  MemCount: integer;	function MemCheck: boolean ;procedure Create_Collection(var C: Collection) ;procedure Destroy(var C: Collection) ;function Size(C: Collection): integer ;function Is_Empty(C: Collection): boolean ;procedure Insert(var C: Collection; V: collection_element) ;procedure Delete(var C: Collection; V: collection_element) ;procedure Join(var C1, C2: Collection) ;procedure Print(C: Collection) ;procedure IdentifyMyself ;procedure ReadKey ;IMPLEMENTATION(***************** Special memory management stuff *******************)(* Place the following ABOVE the collection procedures and functions *)(* Use Get_CNode instead of "new" *)procedure Get_CNode(var C: Collection_node_pointer) ;begin	new(C);	MemCount := MemCount + 1;end;(* Use Return_CNode instead of "dispose" *)procedure Return_CNode(var C: Collection_node_pointer) ;begin	dispose(C);	MemCount := MemCount - 1;end;function MemCheck ;begin	MemCheck := (MemCount = 0);end;{ Specifications:These headers should go in the "implementation" section of "a1unit.pas".ÊEach header should be followed by your code to implement the operation. }procedure Create_Collection ;  (* preconditions: C is undefined   * postconditions: C is the empty collection with storage allocated as needed. *)BEGIN	new(C) ;	inc(MemCount) ;	C^.size := 0 ;	C^.first := Nil ;	C^.last := NilEND;  { proc Create_Collection }	procedure Destroy ;  {* preconditions: C is a defined collection   * postconditions: C' is undefined. All dynamically allocated memory }var	K: collection_node_pointer ;BEGIN	while ( C^.size > 0 ) do		BEGIN		K := C^.first ;		C^.first := K^.next ;		return_Cnode(K) ;		dec(C^.size) ;		END;  { while }	dispose(C) ;	dec(MemCount)	END;  { proc Destroy }function Size ;  (* preconditions: C is a defined collection.   * postconditions: returns the number of elements in C. *)BEGIN	Size := C^.size ;END; { fxn Size }function Is_Empty ;  (* preconditions: C is a defined collection.   * postconditions: returns true if C is empty, false otherwise. *)BEGIN	Is_empty := (C^.size = 0) ;END;  { fxn Is_Empty }procedure Insert ;  (* preconditions: C is a defined collection, V is a collection element.   * postconditions: C has value V added. Storage is allocated as needed. If     V already occurs in C an additional copy is added. *)var	temp: collection_node_pointer ;BEGIN	get_Cnode(temp) ;	temp^.value := V ;	temp^.next := C^.first ;	C^.first := temp ;	if ( C^.last = Nil ) then		C^.last := temp ;	inc(C^.size)END;  { proc Insert }procedure Delete ;  {* preconditions: C is a defined collection, V is a collection element   * postconditions: C has the value V removed. If V occurs more than once,     only one occurrence is removed. If V does not occur in C, no change is made. *}var	K, temp: collection_node_pointer ;BEGIN	if ( C^.size > 0 ) & ( C^.first^.value = V ) then		BEGIN		K := C^.first ;		C^.first := K^.next ;		return_Cnode(K) ;		K := Nil ;		if ( C^.first = Nil ) then			C^.last := Nil ;		dec ( C^.size )		END { if }	else		BEGIN		K := C^.first ;		while ( K <> Nil ) & ( K^.next <> Nil ) do			BEGIN			if ( K^.next^.value = V ) then				BEGIN				temp := K^.next ;				K^.next := temp^.next ;				if ( C^.last = temp ) then					C^.last := K ;				return_Cnode(temp) ;				temp := Nil ;				dec(C^.size) ;				break				END  { if }			else				K := K^.next			END  { while }		END  { else }END;  { proc Delete }procedure Join ;  {* preconditions: C1 and C2 are two different defined collections.   * postconditions: C1 is the union of the two collections (i.e. it     contains all the elements originally in C1 and C2).  C2 is undefined. }BEGIN	if ( C2^.size > 0 ) then		BEGIN		C1^.last^.next := C2^.first ;		C1^.last := C2^.last ;		C1^.size := ( C1^.size + C2^.size ) ;		END;  { if }	dispose(C2) ;	C2 := Nil ;	dec(MemCount)END;  { proc Join }procedure Print ;  {* preconditions: C1 is a defined collection.   * postconditions: The elements in C1 are printed to the screen in any     order.Ê If C1 is empty, the message "EMPTY COLLECTION" is printed to the screen. }var	K: collection_node_pointer ;BEGIN	if ( C^.size = 0 ) then		writeln( 'EMPTY COLLECTION' )	else		BEGIN		K := C^.first ;		while K <> Nil do			BEGIN			writeln( K^.value ) ;			K := K^.next ;			END  { while }		END  { else }END;  { proc Print }procedure IdentifyMyself;begin	writeln;	writeln('***** Student Name:  Mark Sattolo');	writeln('***** Student Number:  428500');	writeln('***** Professor Name:  Sam Scott');	writeln('***** Course Number:  CSI-2114');	writeln('***** T.A. Name:  Adam Murray');	writeln('***** Tutorial Number:  D-1');	writeln;end;  { proc IdentifyMyself }procedure ReadKey ;BEGIN	readln ;END;  { proc ReadKey }(******************** INITIALIZATION CODE **********************)(* this must be placed AT THE END of the TPU file.Ê If you want to initialize other	globals, you may do so by adding code to this section *)begin	MemCount := 0;END.