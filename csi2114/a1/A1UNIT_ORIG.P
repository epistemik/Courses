UNIT  a1unit ;INTERFACE{ Type Definitions:  To be included in the "interface" section of the file"a1unit.pas". }type(*Collection_element = the data type to store in the collection *)	collection_element = string;(*Collection_node = a node in the linked list storing the collection elements *)	collection_node_pointer = ^collection_node;	collection_node =	record								value: collection_element;								next: collection_node_pointer;							end;(*Collection_header = a record containing information about the size of thecollection, as well as pointers to the first and last elements *)	collection_header = record								size: integer;								first: collection_node_pointer;								last: collection_node_pointer;							  end;(*Collection = the main data type of the collection. It is a pointer to a collection header *)	collection = ^collection_header;var  MemCount: integer;	function MemCheck: boolean ;procedure Create_Collection(var C: Collection) ;procedure Destroy(var C: Collection) ;function Size(C: Collection): integer ;function Is_Empty(C: Collection): boolean ;procedure Insert(var C: Collection; V: collection_element) ;procedure Delete(var C: Collection; V: collection_element) ;procedure Join(var C1, C2: Collection) ;procedure Print(C: Collection) ;procedure IdentifyMyself ;procedure ReadKey ;IMPLEMENTATION(***************** Special memory management stuff *******************)(* Place the following ABOVE the collection procedures and functions *)(* Use Get_CNode instead of "new" *)procedure Get_CNode(var C: Collection_node_pointer) ;begin	new(C);	MemCount := MemCount + 1;end;(* Use Return_CNode instead of "dispose" *)procedure Return_CNode(var C: Collection_node_pointer) ;begin	dispose(C);	MemCount := MemCount - 1;end;function MemCheck ;begin	MemCheck := (MemCount = 0);end;{ Specifications:These headers should go in the "implementation" section of "a1unit.pas".ÊEach header should be followed by your code to implement the operation. }procedure Create_Collection ;  (* preconditions: C is undefined   * postconditions: C is the empty collection with storage allocated as needed. *)BEGIN	new(C) ;	inc(MemCount) ;	C^.size := 0 ;	C^.first := Nil ;	C^.last := NilEND;  { proc Create_Collection }	procedure Destroy ;  {* preconditions: C is a defined collection   * postconditions: C' is undefined. All dynamically allocated memory }var K: collection ;BEGIN	if C^.size > 0 then		BEGIN		K := C ;		K^.first := K^.first^.next ;		dec(K^.size) ;		Destroy(K) ;		return_Cnode(C^.first) ;		END  { if }	else		BEGIN		dispose(C) ;		dec(MemCount)		END  { else }END;  { proc Destroy }function Size ;  (* preconditions: C is a defined collection.   * postconditions: returns the number of elements in C. *)BEGIN	Size := C^.size ;END; { fxn Size }function Is_Empty ;  (* preconditions: C is a defined collection.   * postconditions: returns true if C is empty, false otherwise. *)BEGIN	Is_empty := (C^.size = 0) ;END;  { fxn Is_Empty }procedure Insert ;  (* preconditions: C is a defined collection, V is a collection element.   * postconditions: C has value V added. Storage is allocated as needed. If     V already occurs in C an additional copy is added. *)var	temp: collection_node_pointer ;BEGIN	get_Cnode(temp) ;	temp^.value := V ;	temp^.next := C^.first ;	C^.first := temp ;	if ( C^.last = Nil ) then		C^.last := temp ;	inc(C^.size)END;  { proc Insert }procedure Delete ;  (* preconditions: C is a defined collection, V is a collection element   * postconditions: C has the value V removed. If V occurs more than once,     only one occurrence is removed. If V does not occur in C, no change is made. *)var	temp: collection_node_pointer ;	K: collection ;BEGIN	if C^.size <> 0 then		if C^.first^.value = V then			BEGIN			temp := C^.first ;			C^.first := C^.first^.next ;			if ( C^.last = temp ) then				C^.last := Nil ;			return_Cnode(temp) ;			dec(C^.size)			END		else			BEGIN			K := C ;			K^.first := K^.first^.next ;			dec(K^.size) ;			Delete(K, V)			ENDEND;  { proc Delete }procedure Join ;  {* preconditions: C1 and C2 are two different defined collections.   * postconditions: C1 is the union of the two collections (i.e. it     contains all the elements originally in C1 and C2).  C2 is undefined. }BEGIN	C1^.last^.next := C2^.first ;	C1^.last := C2^.last ;	C1^.size := C1^.size + C2^.size ;	dispose(C2) ;	dec(MemCount)END;  { proc Join }procedure Print ;  {* preconditions: C1 is a defined collection.   * postconditions: The elements in C1 are printed to the screen in any     order.Ê If C1 is empty, the message "EMPTY COLLECTION" is printed to the screen. }var K: collection ;BEGIN	if C^.size > 0 then		BEGIN		K := C ;		if ( K^.first^.next ) = Nil then			writeln( K^.first^.value )		else			BEGIN			K^.first := K^.first^.next ;			dec(K^.size) ;			Print(K)			END  { else }		END  { if }	else		writeln( 'EMPTY COLLECTION' ) ;END;  { proc Print }procedure IdentifyMyself;begin	writeln;	writeln('***** Student Name:  Mark Sattolo');	writeln('***** Student Number:  428500');	writeln('***** Professor Name:  Sam Scott');	writeln('***** Course Number:  CSI-2114');	writeln('***** T.A. Name:  Adam Murray');	writeln('***** Tutorial Number:  D-1');	writeln;end;  { proc IdentifyMyself }procedure ReadKey ;BEGIN	readln ;END;  { proc ReadKey }(******************** INITIALIZATION CODE **********************)(* this must be placed AT THE END of the TPU file.Ê If you want to initialize other	globals, you may do so by adding code to this section *)begin	MemCount := 0;END.