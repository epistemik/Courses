CSI 2114   Assignment 2   Summer 1999 So you finished your implementation of the collection ADT and delivered it to your boss (assignment 1).  But she is not happy.  Now she is saying that the delete operation was the most important one and it is too slow!  You argue that delete may be linear time, but the other operations are mostly constant time.  But that's not good enough.  Delete has to be faster.So it's back to the drawing board.Luckily, you have learned about binary search trees, and you know that if you used a binary search tree instead of a linked list to implement the collection, many of the collection operations could be implemented in logarithmic time.  Furthermore, someone else has already implemented a generic binary tree ADT in a Pascal unit file that you can use.  So all you will need to do is re-implement the collection operations so that the data is stored in a binary search tree, and you can do that using the basic binary tree operations so you won't have to do any direct pointer manipulation.To make things even easier, someone has already written a bunch of code including the entire delete procedure.   All that's left is Size, Join, and Insert.Question 1-----------In this assignment, you are given four files:- "bintradt.pas" is a Pascal unit file that implements the binary tree ADT as discussed in class.  - "a2unit.pas" is a Pascal unit file that implements the collection ADT as a binary search tree using the operations from "bintradt.pas".  It is almost finished.  The only thing left to do is implement the procedure bodies for the Size function, the Join procedure, and the Insert procedure.- "a2test1.pas" is a test program that uses the previous two unit files to test the collection in a style very similar to the assignment 1 test program.- "a2test2.pas" is another test program that lets you manage two collections yourself.  You can insert, delete, print, etc. as much as you want so you can test your code thoroughly.If you compile the two units, you should be able to run the two test programs without even writing any code.  The only problem is that when the missing procedures are called you will get a "not implemented" message on the screen.So your job is to write the following code:a) the body of the Size function,b) the body of the Join procedure, andc) the Insert procedure.You should not change any of the rest of the code, and you should hand in all the files on a disk along with compiled versions of both test programs ("a2test1.exe" and "a2test2.exe").  Your code should use the operations from "bintradt.pas".  Do not do any direct pointer references.  For example, instead of writing:        Temp := Tree^.LeftChildwrite this instead:        Temp := LeftChild_BT(Tree)Question 2-----------The boss also needs a quick report on the efficiency of the new collection ADT.  On a separate sheet of paper, write down the complexity of the new implementation of each collection operation in O-notation.Marking Scheme----------------        Size Function    				         5        Join Procedure          			 15        Insert Procedure       			 15        Programming Standards   10        Complexity Analysis      		5        --------------------------        Total                   						 50What to do next----------------Read the "suggestions" file.Suggestions and Tips on How to Proceed-----------------------------------------1.	Compile the two units and try to run the test programs.2.	Read the binary tree ADT specification file, and then read the "bintradt.pas" unit that implements it.  Make sure you understand everything that is going on.3.	Now read the collection ADT specification file and the "a2unit.pas" unit that implements it.  Note the type definitions: "collection" is defined as a "BinaryTree" while "collection_element" is simply "TreeElement".  This means that these names are interchangeable in the code you are writing, but the main public types for the collection are still the same.  Read the code for the operations that have been implemented (delete, print, create, etc.) and make sure you understand what each of them is doing.  4.	Start with the insert procedure.  You can do this in a loop or using recursion.  When you finish this procedure you can test it thoroughly using a2test2.pas, since you already have working procedures to print and delete. Try simulating insertion yourself on paper, or using the on-line demo from class.  Try to identify tricky cases and make sure your insert still preserves the order in these cases.     Note: you have to allow duplicate elements in your tree.   This is a little non-standard, but it's perfectly ok.  Just   pick either the left or right subtree and insert there.5.	Do the easy one next - the Size function.  Note that there is no "size" field in this data structure, so you will have to count the nodes one by one.  Test this function separately to see if it works - you can do this, since you have just written and tested the insert function.6.	Finally, do the join procedure.  The goal of join is to somehow get all the stuff from C2 into C1.  The catch is that both C1 and C2 are binary search trees, so the order has to be maintained.  Test this procedure separately as well.7.	Do lots of testing.  "a2test2.pas" gives you the ability to create any shape of tree you want.  This will allow you to test any of the special cases that you can think of.  Simply insert the elements in an order that will get you the shape of tree you want, then see if it prints and reports the size ok.  You can also test Join in the same way.8.	Comment your code really well.  Label the parts of the code that handle different cases.  Include brief explanations at every step of the code.  Also make sure your indentation is consistent.  In code with a lot of cases (if statements) it's easy to get lost.9.	Don't be afraid to add new procedures to the implementation if you need them.  But comment them well, making sure you give each one a specification with preconditions and postconditions.10. Have fun!