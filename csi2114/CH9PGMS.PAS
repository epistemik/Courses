{--------------------------program 9.20-------------------------} UNIT PriorityQueueTypesUnit;INTERFACE   CONST     MaxCount = 10;   TYPE     PQItem = Integer;     PQArray = ARRAY[1..MaxCount] OF PQItem;     PriorityQueue = RECORD                       Count    :  Integer;                       ItemList :  PQArray;                     END{RECORD};END{UNIT}.{--------------------------program 9.21-------------------------} UNIT HeapPriorityQueueUnit;INTERFACE  USES PriorityQueueTypesUnit;    {defines types: PQItem and PriorityQueue}   PROCEDURE Initialize(VAR PQ:PriorityQueue);   FUNCTION Empty(PQ:PriorityQueue):Boolean;   FUNCTION Full(PQ:PriorityQueue):Boolean;   PROCEDURE Insert(Item: PQItem; VAR PQ:PriorityQueue);   FUNCTION Remove(VAR PQ:PriorityQueue):PQItem;IMPLEMENTATION   {----------------------------}     PROCEDURE Initialize{(VAR PQ:PriorityQueue)};   BEGIN    PQ.Count := 0;   END{Initialize};   {----------------------------}     FUNCTION Empty{(PQ:PriorityQueue):Boolean};   BEGIN     Empty := (PQ.Count = 0);   END{Empty};   {----------------------------}     FUNCTION Full{(PQ:PriorityQueue):Boolean};   BEGIN     Full := (PQ.Count = MaxCount);   END{Full};   {----------------------------}     PROCEDURE Insert{(Item: PQItem; VAR PQ:PriorityQueue)};     VAR ChildLoc,ParentLoc:Integer; Finished:Boolean;   BEGIN           WITH PQ DO BEGIN        Count := Count + 1;                 {caution: insertion does not}        ChildLoc:= Count;                        {guard against overflow}        Parent := ChildLoc div 2;        Finished := (ParentLoc = 0);        WHILE (not Finished) DO BEGIN          IF  Item <= ItemArray[ParentLoc] THEN            Finished := true          ELSE BEGIN                  {here, Item > ItemArray[ParentLoc]}            ItemArray[ChildLoc] := ItemArray[ParentLoc];            ChildLoc := ParentLoc;            ParentLoc := ParentLoc div 2;            Finished := (ParentLoc = 0)          END{IF};        END{WHILE};        ItemArray[ChildLoc] := Item;      {Item goes in final resting place}     END{WITH};   END{Insert};   {----------------------------}     FUNCTION  Remove{(VAR PQ:PriorityQueue):PQItem};     VAR        CurrentLoc, ChildLoc: Integer;        ItemToPlace: PQItem;        Finished: Boolean;   BEGIN     WITH PQ DO BEGIN       IF Count > 0 THEN BEGIN    {result is undefined if PQ was empty}           Remove := ItemArray[1];           ItemToPlace := ItemArray[Count];    {save value of last leaf}           Count := Count - 1;         {delete last leaf in level order}           CurrentLoc := 1;              {CurrentLoc starts at the root}           ChildLoc := 2 * CurrentLoc;           Finished := (ChildLoc > Count);             WHILE not Finished DO BEGIN            {Set ChildLoc to the location of the larger child of CurrentLoc}          IF ChildLoc < Count THEN BEGIN         {if right child exists}            IF ItemArray[ChildLoc + 1] > ItemArray[ChildLoc] THEN BEGIN              ChildLoc := ChildLoc + 1;            END{IF};          END{IF};             {If item at ChildLoc is larger than ItemToPlace, move this}        {larger item to CurrentLoc, and move CurrentLoc down}          IF ItemArray[ChildLoc] <= ItemToPlace THEN            Finished := true                 {to force loop termination}          ELSE BEGIN            ItemArray[CurrentLoc] := ItemArray[ChildLoc];            CurrentLoc := ChildLoc;            ChildLoc := 2 * CurrentLoc;            Finished := (ChildLoc > Count)          END{IF};            END{WHILE};         {final placement of ItemToPlace}        ItemArray[CurrentLoc] := ItemToPlace          END{IF}       END{WITH}     END{Remove};   {----------------------------}  BEGIN      {there is no initialization}   END{UNIT}.{--------------------------program 9.28-------------------------} PROCEDURE Traverse(T:NodePointer; TraversalOrder:OrderOfTraversal);    {to visit T's nodes in the order specified by the TraversalOrder parameter}  BEGIN    IF T <> nil THEN BEGIN                       {If T = nil, do nothing}     IF TraversalOrder = PreOrder THEN         BEGIN        Visit(T);        Traverse(T^.LLink, PreOrder);        Traverse(T^.RLink, PreOrder)        END     ELSE IF TraversalOrder = InOrder THEN        BEGIN        Traverse(T^.LLink, InOrder);        Visit(T);        Traverse(T^.RLink, InOrder)        END     ELSE IF TraversalOrder = PostOrder THEN BEGIN        Traverse(T^.LLink, PostOrder);        Traverse(T^.RLink, PostOrder);        Visit(T)     END{IF}  END{IF}  END{Traverse};{--------------------------program 9.29-------------------------} PROCEDURE PreOrderTraversal(T:NodePointer);    USES       StackADT;            {to use the operations in Figure 7.3, Chapter 7}    VAR       S : Stack;       N : NodePointer;BEGIN    InitializeStack(S);        {initialize the stack S to be the empty stack}  Push(T,S);                            {push the pointer T onto the stack}    WHILE (not Empty(S)) DO BEGIN      Pop(S,N);                                 {pop top pointer of S into N}      IF (N <> nil) THEN BEGIN      Write(N^.Symbol);                 {when visiting N, print its symbol}      Push(N^.RLink,S);                         {push right pointer onto S}      Push(N^.LLink,S);                          {push left pointer onto S}    END{IF}    END{WHILE}  END{PreOrderTraversal};{--------------------------program 9.30-------------------------} PROCEDURE LevelOrderTraversal(T:NodePointer);    USES       QueueADT;           {to use the operations in Figure 7.4 in Chapter 7}    VAR       Q : Queue;       N : NodePointer;   BEGIN    InitializeQueue(Q);         {initialize the queue Q to be the empty queue}  Insert(T,Q);                           {insert the pointer T into queue Q}    WHILE (not Empty(Q)) DO BEGIN    Remove(Q,N);                 {remove first pointer of Q and put it in N}    IF (N <> nil) THEN BEGIN      Write(N^.Symbol);      Insert(N^.LLink,Q);                 {insert left pointer on rear of Q}      Insert(N^.RLink,Q)                 {insert right pointer on rear of Q}    END{IF}  END{WHILE}  END{LevelOrderTraversal};{---------------------------------------------------------------} 