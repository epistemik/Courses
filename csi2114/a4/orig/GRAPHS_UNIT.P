UNIT GraphsUnit ;INTERFACE{************* CONSTANTS ******************}Const	INFINITY = MAXINT;        { Use this anywhere you need "infinity" }	MAX = 33;	{ This is the maximum size of graph. You can make this bigger if you want. }{************* TYPE DEFINITIONS *********************}Type{ These type definitions define an adjacency matrix graph representation that stores edge weights. }	GraphSize = 0..MAX;	VertexNumber = 1..MAX;	AdjacencyRow = Array [VertexNumber] of integer;	GraphRep = Array [VertexNumber] of AdjacencyRow;{ forward declarations }procedure NewGraph( var G:GraphRep; S:GraphSize);procedure AddEdge( var G:GraphRep; S:GraphSize; Origin, Terminus: VertexNumber; Weight: integer );procedure ShortestPath(	var G: GraphRep; S: GraphSize; Origin: VertexNumber;			var ShortestDistance: AdjacencyRow ) ;procedure DisplayMST(G: GraphRep; S: GraphSize) ;procedure Show_adj_matrix ( G: graphrep; S: graphsize ) ;procedure IdentifyMyself;IMPLEMENTATION{procedure NewGraph(G,S)	pre: S is the size of graph to create.	post: G should be an adjacency matrix or adjacency list that corresponds to a graph with	      S vertices and no edges. If using an adjacency matrix, you must initialize the entire matrix. HINT: Remember that the distance from a vertex to itself is always 0.}procedure NewGraph ;var	i, j: integer ;begin     for i := 1 to S do        for j := 1 to S do           if i = j then              G[i, j] := 0	   else	      G[i, j] := INFINITYend;  { proc NewGraph }{procedure AddEdge(G,S,Origin,Terminus,Weight)	pre: G is a graph representation with S vertices.             Origin, Terminus, and Weight define an edge to be added to G.	post: G has the specified edge added.  HINT - you might want to print              an error message if Origin or Terminus are bigger than S.}procedure AddEdge ;begin	if ( not ( Origin in [1.. S] ) ) or ( not ( Terminus in [1..S] ) ) then		writeln( 'Error: Origin and Terminus must be in the range 1 to ', S )	else if ( Origin = Terminus ) and ( Weight <> 0 ) then		writeln( 'Error: the distance from a vertex to itself is always 0. ' )		else			G[Origin][Terminus] := Weightend;  { proc AddEdge }{procedure ShortestPath(G,S,Origin,ShortestDistance)	pre: G is a graph representation with S vertices.  Origin is the start vertex.	post: ShortestDistance is an array containing the shortest distances from Origin to each vertex. HINT - program strategy 10.16 uses set variables.  This is possible in Pascal, but you can't really 	use them the way you need to here.  I suggest implementing the set W as an array 	of booleans.  Initialize them all to FALSE and then each time you want to put a new 	vertex in the set, change the corresponding value to TRUE.  You also might want to 	keep a count of the number of vertices in W. HINT - Watch out for the two "W" variables in 10.16.  They use a big W and a small w. 	You can't do that in Pascal.  I suggest using "w" for the small one and "BigW" for 	the big one.  Of course you are free to use whatever variable names you want, but 	the closer you stick to the book, the easier it will be to mark. HINT - Comment this well! }procedure ShortestPath ;var   Edges: GraphRep ;   ans: string[13] ;   V, BigW : set of GraphSize ;   MinDistance : integer ;   w, i, j, k, l : VertexNumber ;begin     NewGraph(Edges, S) ;     V := [1..S] ;     BigW := [Origin] ;     for i := 1 to S do     	BEGIN     	ShortestDistance[i] := G[Origin, i] ;     	if ( G[Origin, i] <> 0 ) and ( G[Origin, i] <> INFINITY ) then AddEdge(Edges, S, Origin, i, 1)     	END ; { for }     while BigW <> V do     	BEGIN     	MinDistance := INFINITY ;     	for j := 1 to S do	   if ( j in ( V - BigW ) ) and ( ShortestDistance[j] <= MinDistance ) then	     BEGIN	     MinDistance := ShortestDistance[j] ;	     w := j	     END ;	BigW := BigW + [w] ;	for k := 1 to S do	   if ( k in ( V - BigW ) ) and ( G[w, k] <> INFINITY ) then	     if ( ShortestDistance[w] + G[w, k] ) < ( ShortestDistance[k] ) then	       BEGIN	       ShortestDistance[k] := ( ShortestDistance[w] + G[w, k] ) ;	       for l := 1 to S do		  if ( l <> k ) then AddEdge(Edges, S, l, k, INFINITY) ;	       AddEdge(Edges, S, w, k, 1)	       END  { if }	END;  { while }     writeln ;     write('Would you like to see the adjacency matrix for the shortest paths (y/n)? ' );     readln(ans); writeln;     if (ans[1] in ['y', 'Y'] ) then       Show_adj_matrix ( Edges, S ) ;end;  { proc ShortestPath }procedure Calc_min_span(G: GraphRep; S: GraphSize; var SpanTree: GraphRep; Start: VertexNumber) ;var   V, W: set of GraphSize ;   Min, i, j, i2, j2 : integer ;begin     V := [1..S] ;     W := [Start] ;     while (W <> V) do	BEGIN	Min := INFINITY ;	for i := 1 to S do           if (i in W) then	     for j := 1 to S do                if (j in (V - W)) and (G[i, j] <= Min) then		  BEGIN		  Min := G[i, j] ;		  i2 := i ;		  j2 := j ;		  END;  { if }	AddEdge(SpanTree, S, i2, j2, Min) ;	W := W + [j2]	END;  { while }end; { proc Calc_min_span }procedure Convert_undirected( var U: graphrep; S: graphsize ) ;var   i, j : integer ;begin     for i := 1 to S do     	for j := i to S do           if i <> j then	     BEGIN	     if U[j, i] = INFINITY then	       	U[j, i] := U[i, j]	     else if U[i, j] = INFINITY then		 U[i, j] := U[j, i]		 else BEGIN		      U[j, i] := ( U[i, j] + U[j, i] ) div 2 ;		      U[i, j] := U[j, i]		      END  { else }	     END  { if }end;  { proc convert_undirected }procedure Show_adj_matrix ( G: graphrep; S: graphsize ) ;var   row, col : integer ;begin     writeln ;     for row := 1 to S do	BEGIN	for col := 1 to S do	   if G[row,col] = INFINITY then	      write ('  INF')	   else	      write (G[row,col]:5) ;	writeln	END;  { for }     writeln;end;  { proc show_adj_matrix }procedure DisplayMST ( G: GraphRep; S: GraphSize ) ;var   SpanTree, U, Umin: GraphRep ;   Start, Ustart: VertexNumber ;   ans : string[13] ;begin     NewGraph(SpanTree, S) ;     repeat     	write('Choose a starting vertex (1 to ', S, '): ') ;     	readln(Start) ;     until Start in [1..S] ;     Calc_min_span(G, S, SpanTree, Start) ;     writeln ('Here is Prim''s algorithm run against the directed graph: ' ) ;     Show_adj_matrix ( SpanTree, S ) ;     writeln ;     write('Would you like to see the MST for the undirected version of this graph (y/n) ? ' ) ;     readln(ans) ;     if (ans[1] in ['y', 'Y'] ) then     	BEGIN	U := G ;	Convert_undirected ( U, S ) ;	writeln ( 'Here is the adjacency matrix for the undirected graph: ' ) ;	Show_adj_matrix ( U, S ) ;	repeat	   write('Choose a starting vertex (1 to ', S, ') for the MST of the undirected graph: ') ;	   readln(Ustart) ;	until Ustart in [1..S] ;	NewGraph(Umin, S) ;	Calc_min_span(U, S, Umin, Ustart) ;	writeln ( 'Here is the adjacency matrix for the MST of the undirected graph: ' ) ;	Show_adj_matrix ( Umin, S ) ;	END  { if }end;  { proc DisplayMST }(**************************** IDENTIFICATION **************************)(* Change this procedure to identify yourself *)procedure IdentifyMyself;begin    writeln;    writeln('***** Student Name: Mark Sattolo');    writeln('***** Student Number: 428500');    writeln('***** Professor Name: Sam Scott');    writeln('***** Course Number: CSI-2114D');    writeln('***** T.A. Name: Adam Murray');    writeln('***** Tutorial Number: D-1');    writeln;end;end.
